#+TAGS: TOBEORG(t) QUESTIONS(q) UNRESOLVED(u) EXTRA(e)
* 3 数组中重复的数字
** 1 找出数组中重复的数字
*** 一边排序一边查重 <<ilink2>>
    #+begin_src java :classname 
      public class Solution {
          public boolean duplicate(int[] numbers, int length, int[] duplication) {
              if (numbers == null || length < 0) return false;

              for (int i = 0; i < length; i++) {
                  if (numbers[i] < 0 || numbers[i] > length - 1) return false;
              }

              for (int i = 0; i < length; i++) {
                  while (numbers[i] != i) {
                      if (numbers[i] == numbers[numbers[i]]) {
                          duplication[0] = numbers[i];
                          return true;
                      }

                      int temp = numbers[i];
                      numbers[i] = numbers[temp];
                      numbers[temp] = temp;
                  }
              }
              return false;
          }
      }
    #+end_src 
    - 极端情况
      - ~if (numbers == null || length < 0)~ -> ~int[] a = null~ 不等于 ~int[] a = new int[0]~
      - ~numbers[i] < 0 || numbers[i] > length - 1~ 筛除异常输入
    - 由于数字在 0~n-1 范围内，假定没有重复数字 -> 简单的遍历与正确位置交换即可重排 -> 最多需要遍历 n 次 -> 交换的同时顺便看下重不重复即可
    - 复杂度
      - $O(n)$
      - $O(1)$
**** Question:                                                    :QUESTIONS:
     - [ ] 从重复的数组是由不重复的数字改变数位数字而来的角度来考虑解法？
*** 排完再遍历
    #+begin_src java :classname 
      public class Solution {
          public boolean duplicate(int[] numbers, int length, int[] duplication) {
              if (numbers == null || length < 0) return false;

              for (int i = 0; i < length; i++) {
                  if (numbers[i] < 0 || numbers[i] > length - 1) return false;
              }

              Arrays.sort(numbers);
              for (int i = 0; i < length - 1; i++) {
                  if (numbers[i] == numbers[i+1]) {
                      duplication[0] = numbers[i];
                      return true;
                  }
              }
              return false;
          }
      }
    #+end_src 
    - ~Arrays.sort()~ 
    - 复杂度
      - $O(nlogn)$
      - $O(1)$
*** 哈希表
    #+begin_src java :classname 
      public class Solution {
          public boolean duplicate(int[] numbers, int length, int[] duplication) {
              if (numbers == null || length < 0) return false;

              for (int i = 0; i < length; i++) {
                  if (numbers[i] < 0 || numbers[i] > length - 1) return false;
              }

              HashSet<Integer> set = new HashSet<>();
              for (int i = 0; i < length; i++) {
                  if (set.contains(numbers[i])) {
                      duplication[0] = numbers[i];
                      return true;
                  }
                  set.add(numbers[i]);
              }
              return false;
          }
      }
    #+end_src 
    - ~HashSet<Integer> set = new HashSet<>()~, ~set.contains()~ and ~set.add()~ 
    - 复杂度
      - $O(n)$
      - $O(n)$
** 2 不修改数组找出重复的数字
*** 辅助数组 
    #+begin_src java :classname 
      public class Solution {
          public int duplicate(int[] numbers, int length) {
              if (numbers == null || length < 2) return -1;

              for (int i = 0; i < length; i++) {
                  if (numbers[i] < 1 || numbers[i] > length - 1) return -1;
              }

              int[] copy = new int[length];
              for (int i = 0; i < length; i++) {
                  if (copy[numbers[i]] == numbers[i]) {
                      return numbers[i];
                  }
                  copy[numbers[i]] = numbers[i];
              }
          }
      }
    #+end_src 
    - 极端情况
      - ~if (numbers == null || length < 2)~
      - ~if (numbers[i] < 1 || numbers[i] > length - 1)~ 
    - 重排顺便查重： ~copy[numbers[i]] = numbers[i]~ 
    - 复杂度
      - $O(n)$
      - $O(n)$
*** 二分查找 <<ilink1>>
    - ~middle~ 放在前半段
      #+begin_src java :classname 
        public class Solution {
            public static int duplicate(int[] numbers, int length) {
                if (numbers == null || length < 2) return -1;

                for (int i = 0; i < length; i++) {
                    if (numbers[i] < 1 || numbers[i] > length - 1) return -1;
                }

                int start = 1, end = length - 1;
                while (end > start) {
                    int middle = (end + start) / 2;
                    int count = 0;
                    for (int i : numbers) {
                        if (i >= start && i <= middle) count ++;
                    }
                    if (count > middle - start + 1) end = middle;
                    else start = middle + 1;
                }
                return end;
            }
        }
      #+end_src
    - ~middle~ 放在后半段
      #+begin_src java :classname 
        while (end > start) {
            int middle = (end + start) / 2 + 1;
            int count = 0;
            for (int i : numbers) {
                if (i >= start && i < middle) count ++;
            }
            if (count > middle - start) end = middle - 1;
            else start = middle;
        }
      #+end_src
    - ~int middle = (end + start) / 2~ + ~if (i >= start && i <= middle)~ vs ~int middle = (end + start) / 2 + 1~ + ~if (count > middle - start) end = middle - 1~
    - ~if (count > middle - start + 1) end = middle~ + ~else start = middle + 1~ vs ~if (count > middle - start) end = middle - 1~ + ~else start = middle~
    - 二分查找 与 [[ilink2][一边排序一边查重]] 输出的重复数字不一定是数组中最先出现的，而另外3种输出的都是最先出现的。
      - 二分查找输出哪个重复数字取决于该数的重复个数以及相邻数字个数
      - [[ilink2][一边排序一边查重]]输出哪个重复数字取决于数组中所有数字的位置
    - 复杂度
      - $O(nlogn)$
      - $O(1)$
**** Question:                                                    :QUESTIONS:
     - [ ] [[ilink2][一边排序一边查重]]输出哪个重复数字与数组中数字位置进一步的关系？
     - [ ] 以上 [[ilink1][二分查找]] 转换成 recursive ？
     - [ ] Iterative vs Recursive 的转换， 联系 61b [[file:~/csnds/Dropbox/orglife/61b_labs.org::<<elink7>>][MergeSort和QuickSort的Iterative和Recursive方法]], [[file:~/csnds/Dropbox/orglife/61b_labs.org::<<elink8>>][Application: IntLists]]; 61a [[file:~/csnds/Dropbox/orglife/61a_labs.org::<<elink1>>][iterative以及recursive的比较]] <<elink1>>
       - [ ] 各自适合的情况
       - [ ] 互相转换的条件
       - [ ] 转换的思路
* 4 二维数组的查找
** 迭代
*** 查右上角 
    #+begin_src java :classname 
      public class Solution {
          public boolean Find(int target, int[][] array) {
              if (array == null || array.length == 0 || array[0].length == 0) return false;
              int row = array.length, col = array[0].length;
              int x = 0, y = col - 1;
              while (x < row && y >= 0) {
                  if (target < array[x][0] || target > array[row-1][y]) return false;
                  if      (target > array[x][y]) x++;
                  else if (target < array[x][y]) y--;
                  else return true;
              }
              return false;
          }
      }
    #+end_src 
    - 3种块：4个角，边块，内部块。其中只有 *右上角* 和 *左下角* 能有效解决问题 -> 关键在于选择 *便于程序实现在二维数组上的排除* 的块进行比较
    - 极端情况
      - ~if (array == null || array.length == 0 || array[0].length == 0)~
      - ~if (target < array[x][0] || target > array[row-1][y])~
    - 复杂度 <<ilink4>>
      - $O(mn)$ 
      - $O(1)$
*** 查左下角
    #+begin_src java :classname 
      public class Solution {
          public boolean Find(int target, int[][] array) {
              if (array == null || array.length == 0 || array[0].length == 0) return false;
              int row = array.length, col = array[0].length;
              int x = row - 1, y = 0;
              while (x >= 0 && y < col) {
                  if (target < array[0][y] || target > array[x][col-1]) return false;
                  if      (target > array[x][y]) y++;
                  else if (target < array[x][y]) x--;
                  else return true;
              }
              return false;
          }
      }
    #+end_src 
*** 查对角 <<ilink3>>                                            :UNRESOLVED:
    #+begin_src java :classname 
      public class Solution {
          public boolean Find(int target, int[][] array) {
              if (array == null || array.length == 0 || array[0].length == 0) return false;
              int row = array.length, col = array[0].length, max = row > col ? col : row;
              int x = 0, y = 0;
              while (x < row && y < col) {
                  if (target < array[x][y]) return false;
                  if (target == array[x][y] || target == array[x+max-1][y+max-1]) return true;
                  if (max == 1) return contains(target, array, x, y, x == row - 1);
                  if (target > array[x+max-1][y+max-1]) {
                      if (y+max == col) {
                          x += max;
                          max = max < row - x ? max : row - x;
                      } else {
                          y += max;
                          max = max < col - y ? max : col - y;
                      }
                      continue;
                  }
                  if (target < array[x+1][y+1]) {
                      return contains(target, array, x+1, y, false) || contains(target, array, x, y+1, true);
                  }
                  else {
                      x += 1;
                      y += 1;
                      max -= 1;
                  }
              }
              return false;
          }

          private boolean contains(int target, int[][] array, int x, int y, boolean row) {
              if (row) {
                  for (int i = y; i < array[0].length; i++) {
                      if (target == array[x][i]) return true;
                  }
              } else {
                  for (int i = x; i < array.length; i++) {
                      if (target == array[i][y]) return true;
                  }
              }
              return false;
          }
      }
    #+end_src 
** 递归                                                          :UNRESOLVED:
** Question:                                                      :QUESTIONS:
   - [ ] [[ilink3][查对角]] 错在算法还是实现？更优的算法？
   - [ ] 怎么转化成递归实现？
   - [ ] 迭代里 [[ilink4][复杂度]] 分析？
* 5 替换空格
** 不新建 ~StringBuilder~ 
*** 使用自带函数
    - ~replaceAll~ in ~String~ 
      #+begin_src java :classname 
        public class Solution {
            public String replaceSpace(StringBuffer str) {
                if (str == null) return null;
                return str.toString().replaceAll(" ", "%20");
            }
        }
      #+end_src
      - 极端情况： ~if (str == null)~ 
      - ~Object~ 转化为 ~String~: [[file:~/csnds/Dropbox/orglife/61b_rnl.org::<<elink12>>][toString()]]
      - ~str.toString().replaceAll(" ", "%20")~
      - 复杂度 <<ilink5>>
        - 
        - $O(n)$
    - ~replace~ in ~StringBuffer~ 
      #+begin_src java :classname 
        public class Solution {
            public String replaceSpace(StringBuffer str) {
                if (str == null) return null;
                int n = str.length();
                for (int i = 0; i < n; i++) {
                    if (Character.isSpace(str.charAt(i))) {
                        str.deleteCharAt(i);
                        str.insert(i, "%20");
                        // str.replace(i, i+1, "%20");
                        n += 2;
                        i += 2;
                    }
                }
                return str.toString();
            }
        }
      #+end_src
      - 判断字符是否为空格： ~Character.isSpace(str.charAt(i))~ 或 ~str.charAt(i) == ' '~
      - 先删再插或者直接替换： ~str.deleteCharAt(i)~ + ~str.insert(i, "%20")~ = ~str.replace(i, i+1, "%20")~
      - ~n += 2~ + ~i += 2~
      - 复杂度 <<ilink6>>
        - $O(n)$
        - $O(n)$
*** 不使用自带函数
    - 从后往前
      #+begin_src java :classname 
        public class Solution {
            public String replaceSpace(StringBuffer str) {
                if (str == null) return null;
                int count = 0, length = str.length();
                for (int i = 0; i < length; i++) {
                    if (Character.isSpace(str.charAt(i))) count += 1;
                }
                if (count == 0) return str.toString();
                int index = length - 1;
                int newLength = index + 1 + 2 * count, newIndex = newLength - 1;
                str.setLength(newLength);
                for (int i = index, j = newIndex; i >= 0; i--) {
                    if (Character.isSpace(str.charAt(i))) {
                        str.setCharAt(j--, '0');
                        str.setCharAt(j--, '2');
                        str.setCharAt(j--, '%');
                    } else {
                        str.setCharAt(j--, str.charAt(i));
                    }
                }
                return str.toString();
            }
        }
      #+end_src 
      - 对数组或字符串进行某种处理时，如果从前往后考虑会导致多次移动，不妨考虑从后往前考虑。
      - 极端情况
        - ~if (str == null)~
        - ~if (count == 0)~   
      - 扩充： ~newLength = index + 1 + 2 * count~ + ~str.setLength(newLength)~
      - ~str.setCharAt(j--, '0')~ + ~str.setCharAt(j--, str.charAt(i))~
      - 复杂度 <<ilink7>>
        - $O(n)$
        - $O(n)$
** 新建 ~StringBuilder~ 
    #+begin_src java :classname 
      public class Solution {
          public String replaceSpace(StringBuffer str) {
              if (str == null) return null;
              StringBuilder newStr = new StringBuilder();
              for (int i = 0; i < str.length(); i++) {
                  if (Character.isSpace(str.charAt(i))) newStr.append("%20");
                  else                                  newStr.append(str.charAt(i));
              }
              return newStr.toString();
          }
      }
    #+end_src 
    - ~StringBuilder newStr = new StringBuilder()~
    - ~newStr.append("%20")~ + ~newStr.append(str.charAt(i))~
    - 复杂度 <<ilink8>>
      - $O(n)$
      - $O(n)$
** 相关题目                                                :UNRESOLVED:EXTRA:
** Question:                                                      :QUESTIONS:
   - [ ] 复杂度的分析： [[ilink5][replaceAll in String]], [[ilink6][replace in StringBuffer]], [[ilink7][从前往后]] 和 [[ilink8][新建StringBuilder]]。其中后两者在空间复杂度上都是 $O(n)$ 的话怎么区分？
* 6 从尾到头打印链表
** 不能改变原链表
*** 迭代
    #+begin_src java :classname 
      import java.util.ArrayList;
      public class Solution {
          public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
              ArrayList<Integer> alist = new ArrayList<>();
              ListNode node = listNode;
              while (node != null) {
                  alist.add(0, (int) node.val);
                  node = node.next;
              }
              return alist;
          }
      }
    #+end_src 
    - ~alist.add(0, (int) node.val)~
    - 复杂度
      - $O(n)$
      - $O(n)$
*** 递归
    #+begin_src java :classname 
      import java.util.ArrayList;
      public class Solution {
          ArrayList<Integer> alist = new ArrayList<>();
          public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
              if (listNode != null) {
                  alist = printListFromTailToHead(listNode.next);
                  alist.add(listNode.val);
              }
              return alist;
          }
      }
    #+end_src 
    - ~alist = printListFromTailToHead(listNode.next)~ + ~alist.add(listNode.val)~ 
    - 复杂度
      - $O(n)$
      - $O(n)$
** 改变原链表                                                    :UNRESOLVED:
** Question:                                                      :QUESTIONS:
   - [ ] 怎么在原链表上将链表翻转？默认有 ~prev~ 和 ~next~ 吗？只有 ~next~ 呢?
* 7 重建二叉树
  #+begin_src java :classname 
    public class Solution {

        public TreeNode reConstructBinaryTree(int[] pre,int[] in) {
            if (pre == null || in == null || pre.length != in.length || pre.length <= 0) return null;
            if (pre.length == in.length && pre.length == 1) return new TreeNode(pre[0]);
            TreeNode root = new TreeNode(pre[0]);
            int index = 0;
            while (in[index] != pre[0]) {
                index += 1;
                if (index >= pre.length) return null;
            }
            int lLen = index, rLen = pre.length - index - 1;
            int[] lpre = new int[lLen], lin = new int[lLen];
            int[] rpre = new int[rLen], rin = new int[rLen];
            System.arraycopy(pre, 1, lpre, 0, lLen);
            System.arraycopy(pre, index+1, rpre, 0, rLen);
            System.arraycopy(in, 0, lin, 0, lLen);
            System.arraycopy(in, index+1, rin, 0, rLen);
            root.left = reConstructBinaryTree(lpre, lin);
            root.right = reConstructBinaryTree(rpre, rin);
            return root;
        }
    }
  #+end_src 
  #+begin_src java :classname 
    import java.util.Arrays;
    public class Solution {
        public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
            if (pre.length == 0 || in.length == 0) {
                return null;
            }
            TreeNode root = new TreeNode(pre[0]);
            // 在中序中找到前序的根
            for (int i = 0; i < in.length; i++) {
                if (in[i] == pre[0]) {
                    // 左子树，注意 copyOfRange 函数，左闭右开
                    root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));
                    // 右子树，注意 copyOfRange 函数，左闭右开
                    root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1, in.length));
                    break;
                }
            }
            return root;
        }
    }
  #+end_src 
  - 重建二叉树 -> 重建根节点的左右子树 -> 大问题分解为相同性质的小问题 -> 递归：根据父树的两种遍历获得左右子树的两种遍历，重建父树即根据左子树的两种遍历重建左子树 + 根据右子树的两种遍历重建右子树。
  - 极端情况
    - ~if (pre == null || in == null || pre.length != in.length || pre.length <= 0)~
    - ~if (pre.length == in.length && pre.length == 1)~
    - ~if (index >= pre.length) return null~ 
  - ~root~ 定义在方法内而不是方法外，这与递归的 *思想或者说目的* 相符
  - Java 的数组拷贝： ~System.arraycopy~ and ~Arrays.copyOfRange~ 
  - ~t.left = reConstructBinaryTree(lpre, lin)~ + ~t.right = reConstructBinaryTree(rpre, rin)~
  - 复杂度
    - $O(n)$
    - $O(n)$
** Question:                                                      :QUESTIONS:
   - [ ] 递归怎么分析时间和空间复杂度？特别是空间，怎么考虑堆栈的复杂度？
* 8 二叉树的下一个节点
** 直接寻找
   #+begin_src java :classname 
     public class Solution {
         public TreeLinkNode GetNext(TreeLinkNode pNode) {
             if (pNode == null) return null;

             if (pNode.right == null) {
                 if (pNode.next == null) return null;
                 else if (pNode.next.left == pNode) return pNode.next;
                 else return findRight(pNode.next);
             }
             return mostLeft(pNode.right);
         }

         private TreeLinkNode mostLeft(TreeLinkNode pNode) {
             TreeLinkNode p = pNode;
             while (p.left != null) {
                 p = p.left;
             }
             return p;
         }

         private TreeLinkNode findRight(TreeLinkNode pNode) {
             TreeLinkNode p = pNode;
             if (p.next == null) return null;
             while (p.next != null) {
                 if (p.next.left == p) return p.next;
                 p = p.next;
             }
             return null;
         }
     }
   #+end_src 
   - ~findRight(pNode.next)~ 和 ~mostLeft(pNode.right)~
   - ~TreeLinkNode p = pNode~ 为了不改变树的结构
   - 复杂度
     - $O(n)$
     - $O(1)$
** 先还原再寻找
   #+begin_src java :classname 
     import java.util.*;
     public class Solution {
         static ArrayList<TreeLinkNode> list = new ArrayList<>();
         public TreeLinkNode GetNext(TreeLinkNode pNode){
             TreeLinkNode par = pNode;
             while(par.next != null){
                 par = par.next;
             }
             InOrder(par);
             for(int i=0;i<list.size();i++){
                 if(pNode == list.get(i)){
                     return i == list.size()-1?null:list.get(i+1);
                 }
             }
             return null;
         }
         void InOrder(TreeLinkNode pNode){
             if(pNode!=null){
                 InOrder(pNode.left);
                 list.add(pNode);
                 InOrder(pNode.right);
             }
         }
     }
   #+end_src 
   - 递归中序遍历： ~InOrder(pNode.left)~ + ~list.add(pNode)~ + ~InOrder(pNode.right)~
   - ~return i == list.size() - 1 ? null : list.get(i+1)~
   - 复杂度
     - $O(n)$
     - $O(n)$
* 9 用两个栈实现队列 <<ilink25>>
  #+begin_src java :classname 
    import java.util.Stack;

    public class Solution {
        Stack<Integer> stack1 = new Stack<Integer>();
        Stack<Integer> stack2 = new Stack<Integer>();
        public void push(int node) {
            stack1.push(node);
        }
        public int pop() {
            if (stack2.empty()) {
                while (!stack1.empty()) {
                    stack2.push(stack1.pop());
                }
            }
            return stack2.pop();
        }
    }
  #+end_src 
  - 队尾添加由 ~stack1.push()~ 实现， 队头删除由 ~stack2.pop()~ 实现。 ~stack1~ 存 *相对队尾* ， ~stack2~ 为空时，队头即在 ~stack1~ 栈底； ~stack2~ 存 *相对队头* ， ~stack1~ 为空时，队尾即在 ~stack2~ 栈底。
  - 栈： ~stack1.push(node)~, ~stack2.empty()~, ~stack1.pop()~
  - 复杂度
    - $O(1)$
    - *渐进* $O(1)$
** 相关题目                                                :UNRESOLVED:EXTRA:
* 10 斐波那契数列
** 1 求斐波那契数列的第n项
*** 迭代（优化递归）
    #+begin_src java :classname 
      public class Solution {
          public int Fibonacci(int n) {
              int[] fib = {0, 1};
              if (n < 0) throw new IllegalArgumentException();
              if (n <= 1) {
                  return fib[n];
              }
              while (n > 1) {
                  int temp = fib[0] + fib[1];
                  fib[0] = fib[1];
                  fib[1] = temp;
                  // fib[1] += fib[0];
                  // fib[0] = fib[1] - fib[0];
                  n -= 1;
              }
              return fib[1];
          }
      }
    #+end_src
    - ~int temp = fib[0] + fib[1]~ + ~fib[0] = fib[1]~ + ~fib[1] = temp~ = ~fib[1] += fib[0]~ + ~fib[0] = fib[1] - fib[0]~
    - 复杂度
      - 递归
        - $O(2^n)$
        - $O(1)$
      - 优化递归
        - $O(n)$
        - $O(1)$
*** 矩阵递归                                               :UNRESOLVED:EXTRA:
** 2 青蛙跳台阶
    #+begin_src java :classname 
      public class Solution {
          public int JumpFloor(int target) {
              int[] fib = {1, 2};
              if (target <= 0) throw new IllegalArgumentException();
              if (target <= 2) {
                  return fib[target - 1];
              }
              while (target > 2) {
                  int temp = fib[0] + fib[1];
                  fib[0] = fib[1];
                  fib[1] = temp;
                  // fib[1] += fib[0];
                  // fib[0] = fib[1] - fib[0];
                  target -= 1;
              }
              return fib[1];
          }
      }
    #+end_src
    #+begin_src java :classname 
      public class Solution {
          public int JumpFloorII(int target) {
              int fib = 1;
              if (target <= 0) throw new IllegalArgumentException();
              while (target > 1) {
                  fib *= 2;
                  target -= 1;
              }
              return fib;
          }
      }
    #+end_src
    - $f(n)=f(n-1)+f(n-2)+...+f(1)$ - $f(n-1)=f(n-2)+f(n-3)+...+f(1)$ -> $f(n)=2 \times f(n-1)$
    - 复杂度
      - $O(n)$
      - $O(1)$
** 相关题目                                                :UNRESOLVED:EXTRA:
** Question:                                                      :QUESTIONS:
   - [ ] 递归的时间复杂度怎么算的 $O(2^n)$ ？
* 11 旋转数组的最小数字
** 二分查找 <<ilink15>>
   #+begin_src java :classname 
     import java.util.ArrayList;
     public class Solution {
         public int minNumberInRotateArray(int[] array) {
             if (array == null || array.length == 0) return 0;
             if (array[0] < array[array.length - 1]) return array[0];
             int max = 0, min = array.length - 1;
             while (max != min - 1) {
                 int middle = (max + min) / 2;
                 // if (array[max] >= array[middle] && array[middle] <= array[min]) min = middle;
                 // else max = middle;
                 if (array[max] <= array[middle] && array[middle] >= array[min]) max = middle;
                 else min = middle;
             }
             return array[min];
         }
     }
   #+end_src 
   - 原数组 *非递减* ，即 *已排序* -> 可以考虑用 *二分法* -> 二分法在一般已排序数组中查找时 *直接* 通过 *目标与中间* 的大小关系得出 *目标所在区间* -> 而此处需要先根据 *中间与两端* 的关系分析 *中间位于原数列的前段还是后段* ，再 *间接得出目标所在区间* -> 同时找到最大最小值
   - 极端情况
     - ~if (array == null || array.length == 0)~
     - ~if (array[0] < array[array.length - 1])~ ，只能由 ~<~ 判断， ~<=~ 不够充分。
   - 关于 *先根据中间与两端的关系* 分析 *中间位于原数列的前段还是后段* ，由于 *非递减* 而不是 *强递增* ，这导致单边的判断是不够的 -> 双边判断保证 ~if (array[max] >= array[middle] && array[middle] <= array[min])~ 或者 ~if (array[max] <= array[middle] && array[middle] >= array[min])~
   - 复杂度
     - $O(logn)$
     - $O(1)$
** 先排序        
   #+begin_src java :classname 
     import java.util.*;
     public class Solution {
         public int minNumberInRotateArray(int [] array) {
             int n = array.length;
             if(n == 0){
                 return 0;
             }
             Arrays.sort(array);
             return array[0];
         }
     }
   #+end_src 
   - ~Arrays.sort()~
   - 复杂度 <<ilink9>>
     - $O(nlogn)$ 还是 $O(n^2)$
     - $O(1)$
** 用优先队列   
   #+begin_src java :classname 
     import java.util.*;
     public class Solution {
         public int minNumberInRotateArray(int [] array) {
             int n = array.length;
             if(n == 0){
                 return 0;
             }
             PriorityQueue<Integer> queue = new PriorityQueue<>();
             for(int i = 0;i<n;i++){
                 queue.add(array[i]);
             }
             return queue.poll();
         }
     }
   #+end_src 
   - ~PriorityQueue<Integer> queue = new PriorityQueue<>()~
   - 复杂度
     - $O(n)$ 还是 $O(nlogn)$
     - $O(n)$
** Question:                                                      :QUESTIONS:
   - [ ] [[ilink9][部分排序数组上快排的复杂度]] ？
   - [ ] 上面优先队列的时间复杂度？ ~add~ 的时间复杂度怎么考虑？
* 12 矩阵中的路径
** 回溯（递归 DFS）<<ilink22>>
   #+begin_src java :classname 
     public class Solution {
         public boolean hasPath(char[] matrix, int rows, int cols, char[] str) {
             if (matrix == null || rows < 1 || cols < 1 || str == null) return false;
             for (int row = 0; row < rows; row++) {
                 for (int col = 0; col < cols; col++) {
                     if (matrix[row*cols+col] == str[0]) {
                         boolean[][] visited = new boolean[rows][cols];
                         if (hasChar(matrix, rows, cols, row, col, str, 0, visited)) return true;
                     }
                 }
             }

             return false;
         }

         private boolean hasChar(char[] matrix, int rows, int cols, int row, int col,
                                 char[] str, int index, boolean[][] visited) {
             if (row < 0 || row >= rows || col < 0 || col >= cols) return false;
             if (matrix[row*cols+col] != str[index] || visited[row][col]) return false;
             if (index == str.length - 1) return true;
             index += 1;
             visited[row][col] = true;
             if(hasChar(matrix, rows, cols, row+1, col, str, index, visited) ||
                hasChar(matrix, rows, cols, row-1, col, str, index, visited) ||
                hasChar(matrix, rows, cols, row, col+1, str, index, visited) ||
                hasChar(matrix, rows, cols, row, col-1, str, index, visited)) return true;
             visited[row][col] = false;
             return false;
         }
     }
   #+end_src 
   - 极端情况
     - ~if (matrix == null || rows < 1 || cols < 1 || str == null)~
     - ~if (row < 0 || row >= rows || col < 0 || col >= cols)~
     - ~if (matrix[row*cols+col] != str[index] || visited[row][col])~
     - ~if (index == str.length - 1)~ 
   - ~matrix[row*cols+col]~ 而不是 ~matrix[row*rows+col]~
   - ~boolean[][] visited = new boolean[rows][cols]~ 默认初始化为全 ~false~
   - 回溯（递归）函数签名定义： ~boolean hasChar(char[] matrix, int rows, int cols, int row, int col, char[] str, int index, boolean[][] visited)~ 
   - 回溯时 ~visited[row][col] = false~ 而不需要更新 ~index~ ，因为回溯到上层递归中 ~index~ *自动少1* ，不需要特意 *引用传递* ~int[] index~ 来更新。
   - 复杂度
     - 
     - 
** 非递归                                                        :UNRESOLVED:
   #+begin_src java :classname 
     import java.util.Stack;
     import java.util.Arrays;
     import java.util.LinkedList;
     public class Solution{

         public static boolean hasPath(char[] matrix, int rows, int cols, char[] str)
         {
              int[] marks = new int[rows*cols];

             for (int row = 0; row < rows; ++row) {
                 for (int col = 0; col < cols; ++col) {
                      Arrays.setAll(marks, i->0);
                     if(isHasPath( matrix,  marks, rows, cols,  row, col,  str)) {
                         return true;
                     }
                 }
             }
             return false;
         }

         public static boolean isHasPath(char[] matrix,int[] marks,  int rows, int cols, int row, int col, char[] str)
         {
            int currentIndex = 0;
            int count = 0;
           // LinkedList<Integer> visitedStack = new LinkedList<>();
            LinkedList<Integer> rowStack = new LinkedList<>();
            LinkedList<Integer> colStack = new LinkedList<>();
            rowStack.push(row);
            colStack.push(col);
            int[][] newIndexes = new int[][]{
                {1, 0},  {-1, 0},  {0, 1}, {0, -1}
            };
            while (!rowStack.isEmpty()){
                count ++;
                int topX = colStack.peek();
                int topY = rowStack.peek();
                int topIndex = topY*cols + topX;
                if(currentIndex == str.length) {
                    return true;
                }
                if(marks[topIndex] ==0) {
                    if(matrix[topIndex]==str[currentIndex]) {
                        for(int j =0; j <newIndexes.length; ++ j){
                            int newX = topX + newIndexes[j][0];
                            int newY = topY + newIndexes[j][1];
                            if(newX>=0&&newX<cols && newY>=0 && newY<rows){
                                int newIndex = newY*cols+newX;
                                if(marks[newIndex] !=1){//not visited.
                                    colStack.push(newX);
                                    rowStack.push(newY);
                                }
                            }
                        }
                        marks[topIndex] = 1;
                        //visitedStack.push(topIndex);
                        currentIndex ++;
                    }else {
                        colStack.pop();
                        rowStack.pop();   
                    }
                } else {
                    //back to the visited
                    marks[topIndex] = 0;
                    colStack.pop();
                    rowStack.pop();   
     //               if(visitedStack.size()>0)
     //               visitedStack.pop();
                    currentIndex --;
                }
            }
            String strlog = String.format("%d x %d: %d", cols, rows, count);
            System.out.println(strlog);
            return false;
         }

     }
   #+end_src 
** Question:                                                      :QUESTIONS:
   - [ ] 回溯和递归？哪类问题适合用回溯？复杂度分析？
   - [ ] 非递归方法？复杂度？
   - [ ] 联系DFS和BFS实现？
* 13 机器人的运动范围
** 回溯 <<ilink23>>
   #+begin_src java :classname 
     public class Solution {
         public int movingCount(int threshold, int rows, int cols) {
             if (threshold < 0 || rows <= 0 || cols <= 0) return 0;
             boolean[][] visited = new boolean[rows][cols];
             return movingCountCore(threshold, rows, cols, visited, 0, 0);
         }

         private int movingCountCore(int threshold, int rows, int cols,
                                     boolean[][] visited, int row, int col) {
             int count = 0;
             if (row < 0 || row >= rows || col < 0 || col >= cols || visited[row][col]) return count;
             if (checkIn(threshold, row, col)) {
                 visited[row][col] = true;
                 count = 1;
                 count += movingCountCore(threshold, rows, cols, visited, row-1, col);
                 count += movingCountCore(threshold, rows, cols, visited, row+1, col);
                 count += movingCountCore(threshold, rows, cols, visited, row, col-1);
                 count += movingCountCore(threshold, rows, cols, visited, row, col+1);
             }
             return count;
         }

         private boolean checkIn(int threshold, int row, int col) {
             int sum = 0;
             while (row > 0 || col > 0) {
                 sum += row % 10;
                 sum += col % 10;
                 row = row / 10;
                 col = col / 10;
             }
             return threshold >= sum;
         }
     }
   #+end_src 
   - 极端情况
     - ~if (threshold < 0 || rows <= 0 || cols <= 0)~
     - ~if (row < 0 || row >= rows || col < 0 || col >= cols || visited[row][col])~ 
   - 回溯（递归）函数签名定义： ~int movingCountCore(int threshold, int rows, int cols, boolean[][] visited, int row, int col)~
   - ~count += movingCountCore(threshold, rows, cols, visited, row-1, col)~
   - ~while (row > 0 || col > 0)~ 
   - 联系12
     - 在矩阵（二维数组）中找路径，运动等问题可以考虑回溯法。
     - 回溯法往往需要为 ~public~ 接口设计一个 ~private~ 的回溯（递归）函数，其返回类型一般由 ~public~ 接口返回类型决定。
   - 复杂度
     - 
     - 
** Question:                                                      :QUESTIONS:
   - [ ] 复杂度分析？
* 14 剪绳子
** 动态规划 
*** 迭代（书中，用数组暂存）<<ilink10>>
    #+begin_src java :classname 
      public class Solution {
          public int cutRope(int target) {
              if (target < 2) return 0;
              if (target == 2) return 1;
              if (target == 3) return 2;
              int[] ropes = new int[target+1];
              ropes[0] = 0;
              ropes[1] = 1;
              ropes[2] = 2;
              ropes[3] = 3;
              int max = 0;
              for (int i = 4, n = target; i <= n; i++) {
                  max = 0;
                  for (int j = 1; j <= i / 2; j++) {
                      ropes[i] = ropes[j] * ropes[i-j];
                      if (ropes[i] > max) max = ropes[i];
                      ropes[i] = max;
                  }
              }
              return ropes[target];
          }
      }
    #+end_src 
    - 动态规划： $f(n)=max(f(i) \times f(n-i))$ ，其中 $0<i<n$ 为切第1刀的长度。 -> *自上而下的递归* 会重复子问题与计算 -> *自下而上* 的计算方式，往往用数组暂存结果
    - 极端情况
      - ~target < 2, target == 2, target == 3~ 
      - 暂存数组： ~ropes[0], ropes[1], ropes[2], ropes[3]~ 
    - ~new int[target+1]~ 调整索引，便于程序理解， ~ropes[i]~ 准确的说并不完全对应着子问题 $f(i)$ ，而是对应着 $max(f(i), i)$
      - ~ropes~ 的 ~0-3~ 并不对应着 $f(0)$ 到 $f(3)$ ， ~ropes[0]~ 只是为了调整索引，而 ~1-3~ 则是为了计算后面的 $f(i)$ 而暂存的参数，它们实际上对应着 ~Math.max(i, f(i))~ 
      - ~4-target~ 才对应着 $f(i)$ ，即把长度为 /i/ 的绳子剪成若干段之后各段长度乘积的最大值：通过 $i/2$ 次比较， ~ropes[i] = max~ 不断更新，最后得到 $i>3$ 之后的 $f(i)$ 并存进 ~ropes[i]~ 
        - ~for (int j = 1; j <= i / 2; j++)~ 只需要考虑一端即可， $f(i) \times f(n-i) = f(n-i) \times f(i)$
    - 复杂度
      - 
      - 
*** 递归 
    #+begin_src java :classname 
      import java.util.Arrays;
      public class Solution {
          public int cutRope(int target) {
              if (target < 2) return 0;
              if (target == 2) return 1;
              if (target == 3) return 2;
              int length = target / 2 + 1;
              int[] ropes = new int[length];
              ropes[0] = 0;
              int max = 0;
              for (int i = 1, n = length; i < n; i++) {
                  ropes[i] = Math.max(cutRope(i), i) * Math.max(cutRope(target-i), target-i);
                  if (max < ropes[i]) max = ropes[i];
              }
              return max;
          }
      }
    #+end_src
    - 书中迭代 [[ilink10][关于动态规划和递归]] 的分析应该是错的，父问题与子问题 *大体同类型* ，但不是 *完全同类型* 问题：不是 $f(n)=max(f(i) \times f(n-i))$ ，应是 $f(n)=max(max(f(i),i) \times max(f(n-i),n-i))$ <<ilink11>> <<elink3>>
      - *大体同类型* ：父子问题的目的大体相同，但条件等方面可能不同，如本题都要选择一个最大值，但条件不同：
        - 父问题需要 *强制分段* 
        - 子问题不要求分段，即子问题可以存在 *不分段的解决方案*
      - *完全同类型* ：父子问题目的、条件、背景等完全相同。
      - 动态规划或递归要求父问题与子问题之间存在 *连贯的依赖定式* ： *大体同类型即可满足，不要求完全同类型*
    - ~int length= target / 2 + 1~
    - ~ropes[i] = Math.max(cutRope(i), i) * Math.max(cutRope(target-i), target-i)~ 
    - 复杂度
      - 
      - 
** 贪婪算法
   #+begin_src java :classname 
     public class Solution {
         public int cutRope(int target) {
             if (target < 2) return 0;
             if (target == 2) return 1;
             if (target == 3) return 2;
             int num3 = target / 3;
             if (target-num3*3 == 1) num3 -= 1;
             int num2 = (target - num3 * 3) / 2;
             return (int) (Math.pow(3, num3) * Math.pow(2, num2));
         }
     }
   #+end_src 
   - 关于2和3
     - 联系动态规划里 [[ilink11][递归]] 的分析，$i \ge 4$ 时 $max(f(i),i) = f(i)$ -> 需要继续割
     - 关于割3or2：尽可能割3，当剩余为4时不割或割2
   - ~if (target-num3*3 == 1)~ 判断剩余为4
   - 复杂度
     - 
     - 
** Question:                                                      :QUESTIONS: <<elink2>>
   - [ ] [[ilink11][关于动态规划和递归父子问题关系]] 的思考对吗？如果对的，那 *大体同类型* 和 *完全同类型* 父子问题间的 *依赖定式* 又各有什么特点？
   - [ ] 动态规划中递归与迭代，什么时候递归可以 *通过数组或别的数据结构暂存* 而转化为迭代？ *递归自上而下* 而转化后的 *迭代自下而上* ？
   - [ ] 动态规划迭代与递归复杂度分析？
   - [ ] 贪婪中怎么证明割3比割2优先级高？即 $3 \times f(i-3) \ge 2 \times f(i-2)$ ？
   - [ ] 贪婪复杂度分析？
* 15 二进制中1的个数
  - 不考虑负数
    #+begin_src java :classname 
      public class Solution {
          public int NumberOf1(int n) {
              int count = 0;
              while (n != 0) {
                  if ((n & 1) == 1) count += 1;
                  n = n >> 1;
              }
              return count;
          }
      }
    #+end_src
    - 负数会陷入 0xFFFFFFFF(~-1~) 的死循环： ~(-1) >> 1 == -1~ 
    - 按位与运算： ~(n & 1)~
    - 右移运算： ~n = n >> 1~ 
  - 1左移
    #+begin_src java :classname 
      public class Solution {
          public int NumberOf1(int n) {
              int count = 0;
              int flag = 1;
              while (flag != 0) {
                  if ((n & flag) != 0) count += 1;
                  flag = flag << 1;
              }
  
              return count;
          }
      }
    #+end_src
    - ~int flag~ 是32位的，需要循环32次
  - 减1再与
    #+begin_src java :classname 
      public class Solution {
          public int NumberOf1(int n) {
              int count = 0;
              while (n != 0) {
                  count += 1;
                  n = n & (n-1);
              }
              return count;
          }
      }
    #+end_src
    - 每次循环将 ~n~ 最右边的 1 -> 0 ，直到 ~n~ 变为0
      - ~n - 1~ 后最右边的 1 -> 0，右边的 0 -> 1
      - ~n = n & (n-1)~ 会把 ~n~ 最右边的 1 -> 0
** 相关题目                                                :UNRESOLVED:EXTRA:
** Question:                                                      :QUESTIONS:
   - [ ] 以上怎么分析复杂度？
* 16 数值的整数次方
** 迭代常规
   #+begin_src java :classname 
     public class Solution {
         public double Power(double base, int exponent) {
             if (Double.compare(base, 0.0) == 0) return 0.0;
             if (exponent == 0) return 1;
             if (exponent < 0) {
                 exponent = 0 - exponent;
                 base = 1 / base;
             }
             double result = base;
             while (exponent > 1) {
                 result *= base;
                 exponent -= 1;
             }
             return result;
         }
     }
   #+end_src
   - 极端情况
     - ~if (Double.compare(base, 0.0) == 0)~
     - ~if (exponent == 0)~ 
   - ~while (exponent > 1)~ 
** 递归
   #+begin_src java :classname 
     public class Solution {
         public double Power(double base, int exponent) {
             if (exponent < 0) {
                 exponent = - exponent;
                 base = 1 / base;
             }
             return getPower(base, exponent);
         }

         private double getPower(double base, int exponent) {
             if (Double.compare(base, 0.0) == 0) return 0.0;
             if (exponent == 0) return 1;
             double result = getPower(base, exponent >> 1);
             result *= result;
             if ((exponent & 1) == 1) result *= base;
             return result;
         }
     }
   #+end_src
   - 对于正数 ~exponent >> 1~ = ~exponent / 2~
   - ~(exponent & 1) == 1~ -> 奇数，否则偶数
   - 复杂度
      - 
      - 
** Question:                                                      :QUESTIONS:
   - [ ] 递归的复杂度分析？
* 17 打印从1到最大的n位数                                        :UNRESOLVED:
* 18 删除链表的节点
** 非递归 <<ilink17>>
   - 暴力法（不新建头结点）
     - 原始（单循环移动头结点）
       #+begin_src java :classname 
         public class Solution {
             public ListNode deleteDuplication(ListNode pHead) {
                 if (pHead != null && pHead.next != null) {
                     if (pHead.val == pHead.next.val) {
                         while (pHead != null && pHead.next != null && pHead.val == pHead.next.val) {
                             pHead = pHead.next;
                             if (pHead.next != null && pHead.val != pHead.next.val) {
                                 if (pHead.next.next != null && pHead.next.val == pHead.next.next.val) {
                                     pHead = pHead.next;
                                 }
                             }
                         }
                         pHead = pHead.next;
                         if (pHead == null) return pHead;
                     }
                     ListNode p = pHead;
                     while (p.next != null && p.next.next != null) {
                         if (p.next.val == p.next.next.val) {
                             ListNode np = p.next;
                             while (np.next != null && np.val == np.next.val) {
                                 np = np.next;
                             }
                             p.next = np.next;
                         } else p = p.next;
                     }
                 }
                 return pHead;
             }
         }
       #+end_src
     - 改进（双循环移动头结点）
       #+begin_src java :classname 
         public class Solution {
             public ListNode deleteDuplication(ListNode pHead) {
                 if (pHead != null && pHead.next != null) {
                     while (pHead.val == pHead.next.val) {
                         ListNode p = pHead.next;
                         while (p != null && p.val == pHead.val) {
                             p = p.next;
                         }
                         pHead = p;
                         if (pHead == null || pHead.next == null) return pHead;
                     }
                     ListNode p = pHead;
                     while (p.next != null && p.next.next != null) {
                         if (p.next.val != p.next.next.val) p = p.next;
                         else {
                             ListNode np = p.next;
                             while (np.next != null && np.val == np.next.val) {
                                 np = np.next;
                             }
                             p.next = np.next;
                         }
                     }
                 }
                 return pHead;
             }
         }
       #+end_src
     - 关键要处理两种情况：头结点删除和非头节点删除
       - 头节点删除：由于是头结点，无法通过修改 ~.next~ 删除节点，只能移动头结点。在 *重复时移动，不重复时停下* 进入 *非头结点删除* 。 <<ilink13>>
         - 单循环实现：直接移动 ~pHead~ ，一次移动 *1* 位，移动到 *某轮重复的最后一位* 时判断 *随后是否接着另一轮重复* ，是则继续头结点删除循环，否则跳出循环进入非头结点删除阶段。
           - 不能一次移动2位，即 ~pHead = pHead.next.next~ ，遇到 ~{1,1,1,2,2}~ 会输出 ~{1}~ 。<<ilink12>>
           - 移动到 *某轮重复最后一位* ~pHead.val != pHead.next.val~ 时需要进一步判断 ~pHead.next.val == pHead.next.next.val~ ，比如 ~{1,1,1,2,2}~ 。即头结点删除可能历经 *若干不同的重复节点* ，此时需要 ~pHead = pHead.next~ 进入下一个 *不同的重复节点* 并继续 *头结点删除的循环* ，而不应该直接跳出循环结束头结点的删除。
         - 双循环嵌套实现： *内循环* 一次移动1位直到 ~p~ 指向 *某次重复完的下一位* ， 外循环将 ~pHead~ *越过某次重复并指向下一位* 来 *间接一次移动多位同一次重复* ，并判断是继续头结点删除，还是跳出循环进入非头结点删除
           - 内循环 ~p = p.next~ 一次移动 *1位* + 外循环 ~pHead = p~ 一次移动 *1轮重复*
       - 非头结点删除： *重复时* 改变 ~p.next~ 跳过并 *改变列表结构* ， *不重复时移动* ~p~ 直到 ~null~
         - *不重复时* 在外循环移动 ~p~ 直到 ~null~ ， *不重复到重复* 进入内循环移动 ~np~ ， *重复到不重复* 跳出内循环由 ~p.next = np.next~ 跳过重复并回到外循环
     - 关于循环条件：主要看 *判断条件的依赖* 和循环中对 *判断条件相关变量的更新*  <<ilink14>>
       - 比较 *当前* 和 *下一位* 并且一次 *移动1位* 时只需要保证 *下一位* 不为 ~null~
         - ~while (pHead.next != null && pHead.val == pHead.next.val)~ + ~pHead = pHead.next~ 
         - ~while (np.next != null && np.val == np.next.val)~ + ~np = np.next~ 
       - *当前* 与 *下一位* 明确 *不重复* ，需要比较 *下一位* 和 *下下位* 并且一次 *移动n位或跳过n位* 时需保证 *当前* 和下一位均不为 ~null~
         - ~while (pHead != null && pHead.next != null && pHead.val == pHead.next.val)~
         - ~while (p.next != null && p.next.next != null)~ 
   - 新建头结点
     #+begin_src java :classname 
       public class Solution {
           public ListNode deleteDuplication(ListNode pHead) {
               if (pHead != null && pHead.next != null) {
                   ListNode p = new ListNode(0);
                   p.next = pHead;
                   ListNode np = p;
                   while (np.next != null && np.next.next != null) {
                       if (np.next.val != np.next.next.val) np = np.next;
                       else {
                           ListNode nnp = np.next;
                           while (nnp.next != null && nnp.val == nnp.next.val) {
                               nnp = nnp.next;
                           }
                           np.next = nnp.next;
                       }
                   }
                   pHead = p.next;
               }
               return pHead;
           }
       }
     #+end_src
     - 新建头结点 ~p.next = pHead~ -> 从 ~p.next~ 即 ~pHead~ 往后删除重复节点 -> 相当于 *略过头结点删除* ，从 *新头结点* ~p~ 开始直接进入 *非头结点删除*
     - ~pHead = p.next~ 
** 递归
     #+begin_src java :classname 
       public class Solution {
           public ListNode deleteDuplication(ListNode pHead) {
               if (pHead == null || pHead.next == null) {
                   return pHead;
               }

               if (pHead.val == pHead.next.val) {
                   ListNode node = pHead.next;
                   while (node != null && node.val == pHead.val) {
                       node = node.next;
                   }
                   return deleteDuplication(node);
               } else {
                   pHead.next = deleteDuplication(pHead.next); 
                   return pHead;
               }

           }
       }
     #+end_src 
     - 关于 [[ilink11][父子问题类型]] 的思考可能是错的，递归中 *父子问题* 的定义应该全是 *完全同类型* 的，即目的条件等完全一致，不存在所谓的 *大体同类型* 。 <<elink4>> <<ilink16>>
     - 各个递归问题的 *不同之处* 在于 *父问题答案* 与 *子问题答案* 之间的 *连贯的依赖定式* 不同，而 *父问题和子问题本身* 是 *完全同类型* 的。
     - 父问题为从 ~pHead~ 开始 ~deleteDuplication~ ， 子问题为从 ~pHead~ 之后的 *某个节点* 开始 ~deleteDuplication~ ，可以看到父子问题本身是 *完全同类型* 的。关键在于子问题 *某个节点的选择* 以及父子问题 *答案的稳定依赖定式*
       - 若头结点重复，则子问题的节点选择为 ~null~ 或 ~node.val != pHead.val~ ，此时父问题答案 *=* 子问题答案，即 ~return deleteDuplication(node)~ 
       - 若头结点不重复，则子问题的节点选择 ~pHead.next~ ，此时父问题答案 *!=* 子问题答案，而是 ~pHead.next = deleteDuplication(pHead.next)~ + ~return pHead~ 
     - 关于递归适用情况的思考 <<ilink18>>
       1. 父子问题容易抽象建模
       2. *最小子问题* 是可解的（不需要递归的），即 *base* 情况
       3. 父子问题的答案存在 *连贯的依赖定式* 且该定式是 *直观可表达的*
       4. 由依赖定式导出的递归方法 *复杂度可接受*
** Question:                                                      :QUESTIONS:
   - [ ] 单循环头结点删除里 [[ilink12][移动2位甚至比n位移动n位]] 有办法用代码实现吗？如果不能该怎么想明白不能呢？
   - [ ] 能否借用二分查找 [[ilink1][1]] [[ilink15][2]] 的办法加速 [[ilink13][头结点的删除]] ？
   - [ ] 关于 [[ilink14][循环条件]] 的思考？如何优化非递归的代码？主要是对 ~while()~ 条件的分析：该写怎样的判断？判断该写在循环条件还是循环内的 ~if~ 语句？
* 19 正则表达式匹配
** 迭代                                                :ITERATIVE:UNRESOLVED:
   #+begin_src java :classname 
     public class Solution {
         public boolean match(char[] str, char[] pattern) {
             int i = 0, j = 0;
             while (i < str.length && j < pattern.length) {
                 if (str[i] == pattern[j] || pattern[j] == '.') {
                     i++;
                     j++;
                     continue;
                 }
                 if (pattern[j] == '*') {
                     j++;
                     continue;
                 }
                 if (str[i] != pattern[j]) {
                     if (j+1 < pattern.length && pattern[j] != '*') return false;
                     else j++;
                 }
             }
             if (i == str.length) {
                 while (j < pattern.length) {
                     if (pattern[j] != '*') {
                         if (j+1 >= pattern.length) return false;
                         else if (pattern[j+1] != '*') return false;
                     }
                     j++;
                 }
                 return true;
             }
             return false;
         }
     }
   #+end_src 
** 递归                                                           :RECURSIVE:
   #+begin_src java :classname 
     public class Solution {
         public boolean match(char[] str, char[] pattern) {
             return matchChar(str, 0, pattern, 0);
         }

         private boolean matchChar(char[] str, int index1, char[] pattern, int index2) {
             if (str == null || pattern == null || index1 < 0 || index2 < 0) return false;
             if (index1 == str.length && index2 == pattern.length) return true;
             else if (index2 == pattern.length)                    return false;

             if (index2+1 < pattern.length && pattern[index2+1] == '*') {
                 if (index1 < str.length && (pattern[index2] == '.' || str[index1] == pattern[index2])) {
                     return matchChar(str, index1, pattern, index2+2) || matchChar(str, index1+1, pattern, index2);
                 } else {
                     return matchChar(str, index1, pattern, index2+2);
                 }
             }

             if (index1 < str.length && (pattern[index2] == '.' || str[index1] == pattern[index2])) {
                 return matchChar(str, index1+1, pattern, index2+1);
             }

             return false;
         }
     }
   #+end_src 
   - 递归父子问题分析
     - 父问题：从当前父索引开始匹配
     - 子问题：从当前子索引（父索引之后）开始匹配
     - *父子问题答案* 的 *连贯依赖定式* ：父问题答案 = 父索引到子索引之前的匹配结果 *&&* 子问题答案
   - ~*~ 前一定要有非 ~*~ 的字符，因此不用考虑匹配到 ~*~ 的情况 -> 是否当前模式字符后为 ~*~ -> 是否 *匹配串未完且当前匹配成功*
     - 模式字符后接着 ~*~
       - 匹配串未完且匹配成功 -> ~return matchChar(str, index1, pattern, index2+2) || matchChar(str, index1+1, pattern, index2)~
         - 没必要 ~matchChar(str, index1+1, pattern, index2+2)~ ，关键在于 ~*~ 是 *0次* 还是 *大于0次* ，而不必继续区分出 *1次* -> 先 *大于0次* + *0次* = *1次*
       - 匹配串已完或匹配失败 -> ~return matchChar(str, index1, pattern, index2+2)~
         - 匹配串已完时 *不再匹配* ，只是在更新 ~index2~ 验证 ~pattern~ 是否 *多余匹配* ，即剩余存在 *连续的非* ~*~ 
         - 匹配未完但匹配失败时才 *继续匹配*
     - 非 ~*~ 或无字符
       - 匹配串未完且匹配成功 -> ~return matchChar(str, index1+1, pattern, index2+1)~
       - 匹配串已完或匹配失败 -> ~return false~
         - 匹配串已完时说明 ~pattern~ 剩下部分有 *连续的非* ~*~ -> *多余匹配*
   - 极端情况
     - ~if (str == null || pattern == null || index1 < 0 || index2 < 0)~
     - ~if (index1 == str.length && index2 == pattern.length)~ -> 匹配串 *且* 模式串结束， *成功匹配*
     - ~if (index1 != str.length && index2 == pattern.length)~ -> 匹配串未完但模式串已完， *不够匹配*
   - 复杂度
     - 
     - 
** Question:                                                      :QUESTIONS:
   - [ ] 递归复杂度分析？
* 20 表示数值的字符串 <<ilink28>>                                    :STRING:
** 正则匹配
*** ~String.matches~ 
    #+begin_src java :classname 
      public class Solution {
          public boolean isNumeric(char[] str) {
              String string = String.valueOf(str);
              return string.matches("[\\+-dfe]?\\d*(\\.\\d*)?([eE][\\+-]?\\d+)?");
          }
      }
    #+end_src 
    - ~String.valueOf~
    - ~string.matches("[\\+-]?\\d*(\\.\\d*)?([eE][\\+-]?\\d+)?")~
      - ~\\~ 表示接的普通字符
      - ~[abc]~ 表示匹配其中的 *某一个* 字符
      - ~?~ 表示之前的可有可无
      - ~*~ 表示出现 *0次或n次*
      - ~(ab)~ 表示字符ab *接连出现*
*** ~Pattern.matches~ 
    #+begin_src java :classname 
      import java.util.regex.Pattern;

      public class Solution {
          public static boolean isNumeric(char[] str) {
              String pattern = "^[-+]?\\d*(?:\\.\\d*)?(?:[eE][-\\+]?\\d+)?$";
              String s = new String(str);
              return Pattern.matches(pattern, s);
          }
      }
    #+end_src 
    - ~Pattern.matches(pattern, s)~ 
** 扫描
   #+begin_src java :classname 
     public class Solution {
         private int index = 0;

         public boolean isNumeric(char[] str) {
             if (str == null || str.length < 1) return false;
             boolean flag = scanInteger(str);
             if (index < str.length && str[index] == '.') {
                 index += 1;
                 flag = scanUnsignedInteger(str) || flag;
             }
             if (index < str.length && (str[index] == 'E' || str[index] == 'e')) {
                 index += 1;
                 flag = scanInteger(str) && flag;
             }

             return flag && (index == str.length);
         }

         private boolean scanInteger(char[] str) {
             if (index < str.length && (str[index] == '+' || str[index] == '-')) index += 1;
             return scanUnsignedInteger(str);
         }

         private boolean scanUnsignedInteger(char[] str) {
             int start = index;
             while (index < str.length && (str[index] >= '0' && str[index] <= '9')) {
                 index += 1;
             }
             return start < index;
         }
     }
   #+end_src 
   - (((A||.a) && !(E/e)) || ((A||.a)&&(E/e)&&A)) && 最后一位完成扫描
     - (A||.a) 即是否存在有理数： ~flag = scanInteger(str) && flag~ ，不能写成 ~flag && scanInteger(str)~ ，要保证 ~scanInteger(str)~ 的执行
     - ((A||.a) && !(E/e)) 即无指数部分，((A||.a)&&(E/e)&&A)即有指数部分： ~flag = scanInteger(str) && flag;~ ，不能写成 ~flag && scanInteger(str)~ ，原因同上
   - 极端情况： ~if (str == null || str.length < 1) return false~ 
   - 设置 ~private int index~ 追踪扫描位置
   - ~scanInteger~ 扫描可能有符号的整数， ~scanUnsignedInteger~ 扫描无符号整数， ~start < index~ 判断是否存在 *无符号整数*
** Question:                                                      :QUESTIONS:
   - [ ] ~Pattern~ 是怎么匹配的？
* 21 调整数组顺序使奇数位于偶数前面
** 使用别的结构存储
   - ArrayList
     #+begin_src java :classname 
       import java.util.ArrayList;

       public class Solution {
           public void reOrderArray(int[] array) {
               if (array == null || array.length <= 1) return;
               ArrayList<Integer> arrayList = new ArrayList<>();
               int nextOdd = 0;
               for (int i = 0; i < array.length; i++) {
                   if (array[i] % 2 == 0) arrayList.add(array[i]);
                   else {
                       arrayList.add(nextOdd, array[i]);
                       nextOdd += 1;
                   }
               }

               for (int i = 0; i < array.length; i++) {
                   array[i] = arrayList.get(i);
               }
           }
       }
     #+end_src
     - 顺序遍历，用 ~ArrayList.add~ 选择合适位置存储
       - 奇数 ~arrayList.add(array[i])~ 
       - 偶数 ~arrayList.add(nextOdd, array[i])~ + ~nextOdd += 1~ 
     - 极端情况： ~if (array == null || array.length <= 1)~ 
     - ~import java.util.ArrayList~ + ~ArrayList<Integer> arrayList = new ArrayList<>()~
     - 复杂度
       - $O(n)$
       - $O(n)$
   - Queue
     #+begin_src java :classname 
       import java.util.Queue;
       import java.util.LinkedList;

       public class Solution {
           public void reOrderArray(int[] array) {
               if (array == null || array.length <= 1) return;
               Queue<Integer> oddQueue = new LinkedList<>();
               Queue<Integer> evenQueue = new LinkedList<>();
               for (int i = 0; i < array.length; i++) {
                   if (array[i] % 2 == 0) evenQueue.add(array[i]);
                   else oddQueue.add(array[i]);
               }

               int i = 0;
               while (!oddQueue.isEmpty()) {
                   array[i] = oddQueue.poll();
                   i += 1;
               }
               while (!evenQueue.isEmpty()) {
                   array[i] = evenQueue.poll();
                   i += 1;
               }
           }
       }
     #+end_src
     - ~import java.util.Queue~ + ~import java.util.LinkedList~
     - ~Queue<Integer> oddQueue = new LinkedList<>()~ 而不是 ~Queue<Integer> oddQueue = new Queue<>()~
     - 复杂度
       - $O(n)$
       - $O(n)$
** [[file:~/csnds/Dropbox/orglife/61b_rnl.org::<<elink16>>][插入排序思想]]
   - 直接插入排序转化
     #+begin_src java :classname 
       public class Solution {
           public void reOrderArray(int[] array) {
               if (array == null || array.length <= 1) return;
               for (int i = 0; i < array.length; i++) {
                   int j = i;
                   while (j > 0) {
                       if (array[j] % 2 == 1 && array[j-1] % 2 == 0) {
                           int temp = array[j-1];
                           array[j-1] = array[j];
                           array[j] = temp;
                           j -= 1;
                       } else break;
                   }
               }
           }
       }
     #+end_src 
     - 插入排序：一共 *n次插入* ，第i次插入需要 *向前交换j次* 直到无需交换， *最多i-1次*
     - ~int j = i~ + ~while (j > 0)~ + ~if (array[j] % 2 == 1 && array[j-1] % 2 == 0)~
     - 复杂度
       - $O(n^2)$
       - $O(1)$
   - 优化
     #+begin_src java :classname 
       public class Solution {
           public void reOrderArray(int[] array) {
               if (array == null || array.length <= 1) return;
               int k = 0;
               for (int i = 0; i < array.length; i++) {
                   if (array[i] % 2 == 1) {
                       int j = i;
                       while (j > k) {
                           int temp = array[j];
                           array[j] = array[j-1];
                           array[j-1] = temp;
                           j -= 1;
                       }
                       k += 1;
                   }
               }
           }
       }
     #+end_src
     - 小的向前碰到大的交换 -> 奇数向前碰到偶数交换 -> 记录已经完成插入的奇数数量，不必每次比较到第0位。
     - ~while(j > k)~ + ~k += 1~ 
     - 复杂度
       - $O(n^2)$
       - $O(1)$
* 22 链表中倒数第k个节点                                               :LIST:
** 用ArrayList暂存
   #+begin_src java :classname 
     /*
       public class ListNode {
       int val;
       ListNode next = null;

       ListNode(int val) {
       this.val = val;
       }
       }*/
     import java.util.ArrayList;

     public class Solution {
         public ListNode FindKthToTail(ListNode head,int k) {
             if (head == null || k < 1) return null;
             ArrayList<ListNode> list = new ArrayList<>();
             ListNode n = head;
             while (n != null) {
                 list.add(0, n);
                 n = n.next;
             }
             return list.size() < k ? null : list.get(k - 1);
         }
     }
   #+end_src 
   - 用 ~ArrayList~ 每次在0处插入，将链表反向存储下来
   - 极端情况
     - ~if (head == null || k < 1) return null~
   - ~import java.util.ArrayList~ + ~ArrayList<ListNode> list = new ArrayList<>()~
   - ~return list.size() < k ? null : list.get(k - 1)~ 
** 两个指针
   #+begin_src java :classname 
     /*
       public class ListNode {
       int val;
       ListNode next = null;

       ListNode(int val) {
       this.val = val;
       }
       }*/
     import java.util.ArrayList;

     public class Solution {
         public ListNode FindKthToTail(ListNode head,int k) {
             if (head == null || k < 1) return null;
             ListNode n1 = head, n2 = head;
             for (int i = 0; i < k; i++) {
                 if (n1 == null) return null;
                 n1 = n1.next;
             }
             while (n1 != null) {
                 n1 = n1.next;
                 n2 = n2.next;
             }
             return n2;
         }
     }
   #+end_src 
   - 用相差k个的两个指针 *同速遍历* --> 1个指针遍历不能解决问题，尝试2指针遍历（速度不一定一样）
   - ~if (n1 == null) return null~ 
** 相关题目                                                :UNRESOLVED:EXTRA:
* 23 链表中环的入口节点                                                :LIST:
** 快慢指针
   #+begin_src java :classname 
     /*
       public class ListNode {
       int val;
       ListNode next = null;

       ListNode(int val) {
       this.val = val;
       }
       }
     ,*/
     public class Solution {

         public ListNode EntryNodeOfLoop(ListNode pHead) {
             if (pHead == null) return null;
             ListNode n1 = pHead, n2 = pHead;
             while (true) {
                 if (n2 == null || n2.next == null) return null;
                 n2 = n2.next.next;
                 n1 = n1.next;
                 if (n2 == n1) break;
             }
             int count = 0;
             while (true) {
                 n2 = n2.next;
                 count += 1;
                 if (n2 == n1) {
                     n1 = n2 = pHead;
                     break;
                 }
             }
             for (int i = 0; i < count; i++) {
                 n2 = n2.next;
             }
             while (n1 != n2) {
                 n1 = n1.next;
                 n2 = n2.next;
             }
             return n1;
         }
     }
   #+end_src 
   - 快慢指针判断是否有环 -> 确定环长度 -> 双指针确定环入口点
     - 快慢指针： ~n2 = n2.next.next~ + ~n1 = n1.next~
     - 确定环长度 *不必须* ，但确定后可以保证 *最短时间* 内找到环入口点
       - 双指针 ~n1~ 指向 *头节点* ， ~n2~ 指向 *快慢指针的相遇节点* --> 无论 ~n2~ 在环中何处，双指针共同遍历必在 *入口点相遇*
         - 快指针路程 = a+(b+c)k+b ，慢指针路程 = a+b ，a+(b+c)k+b = 2*(a+b) --> a = (k-1)(b+c)+c --> 确定环长度可以确保 k-1=0 ，即 *最快*
     - 双指针 ~n1 = n2 = pHead~ 并在环长度次后 ~n2 = n2.next~ 后， ~n1~ 到 ~n2~ 长度 *比环长度大1* -> ~n1.next = n3~ 时必有 ~n2.next = n3~ ，即必在环入口点 ~n3~ 相遇：
   - 1个指针遍历不能解决的列表问题，尝试2指针遍历（甚至 [[ilink17][多节点]] ）
* 24 反转链表                                                          :LIST:
** 迭代                                                           :ITERATIVE:
*** 用ArrayList暂存辅助反转
    #+begin_src java :classname 
      /*
        public class ListNode {
        int val;
        ListNode next = null;

        ListNode(int val) {
        this.val = val;
        }
        }*/
      import java.util.ArrayList;

      public class Solution {
          public ListNode ReverseList(ListNode head) {
              if (head == null || head.next == null) return null;
              ArrayList<Integer> list = new ArrayList<>();
              ListNode n = head;
              while (n != null) {
                  list.add(0, n.val);
                  n = n.next;
              }
              n = head;
              for (int i = 0; i < list.size(); i++) {
                  n.next = new ListNode(list.get(i));
                  n = n.next;
              }
              return head.next;
          }
      }
    #+end_src 
    - 用 ~ArrayList.add(0,)~ 反转存储
    - 极端情况： ~if (head == null || head.next == null)~ 
    - ~list.add(0, n.val)~ + ~n.next = new ListNode(list.get(i))~
    - 复杂度
      - $O(n)$
      - $O(n)$
*** 双指针
    #+begin_src java :classname 
      /*
        public class ListNode {
        int val;
        ListNode next = null;

        ListNode(int val) {
        this.val = val;
        }
        }*/

      public class Solution {
          public ListNode ReverseList(ListNode head) {
              if (head == null || head.next == null) return null;
              ListNode p = head;
              while (head.next != null) {
                  ListNode q = new ListNode(head.next.val);
                  q.next = p;
                  p = q;
                  head.next = head.next.next;
              }
              return p;
          }
      }
    #+end_src 
    - 维护一个头节点 ~p~ ，一个尾节点 ~head~ ：根据 ~head.next.val~ 新建头节点 -> 更新头节点 -> 更新 ~head.next~
    - 复杂度
      - $O(n)$
      - $O(1)$
*** 三指针
    - 以 *未反转头节点的下一节点* 判断
      #+begin_src java :classname 
        /*
          public class ListNode {
          int val;
          ListNode next = null;
  
          ListNode(int val) {
          this.val = val;
          }
          }*/
  
        public class Solution {
            public ListNode ReverseList(ListNode head) {
                if (head == null || head.next == null) return null;
                ListNode p = null, q = head, m = head.next;
                while (m != null) {
                    q.next = p;
                    p = q;
                    q = m;
                    m = m.next;
                }
                q.next = p;
                return q;
            }
        }
      #+end_src
    - 以 *未反转头节点* 判断
      #+begin_src java :classname 
        /*
          public class ListNode {
          int val;
          ListNode next = null;

          ListNode(int val) {
          this.val = val;
          }
          }*/

        public class Solution {
            public ListNode ReverseList(ListNode head) {
                if (head == null || head.next == null) return null;
                ListNode pre = null, next = null;
                while (head != null) {
                    next = head.next;
                    head.next = pre;
                    pre = head;
                    head = next;
                }
                return pre;
            }
        }
      #+end_src 
    - 维持3个指针指向 *已反转的头节点* ， *未反转的头节点* ，以及 *未反转头节点的下一节点* ： ... <-- ~pre~ <x- ~head~ --> ~next~ --> ...
      - 以 ~next~ 判断， 当 ~next == null~ 时， ~head.next = pre~ + ~return head~
      - 以 ~head~ 判断， 当 ~head == null~ 是， ~return pre~ ，比前者 *多走1次循环*
    - 复杂度
      - $O(n)$
      - $O(1)$
** 递归                                                           :RECURSIVE:
   #+begin_src java :classname 
     /*
       public class ListNode {
       int val;
       ListNode next = null;

       ListNode(int val) {
       this.val = val;
       }
       }*/

     public class Solution {
         public ListNode ReverseList(ListNode head) {
             if (head == null || head.next == null) return head;
             ListNode reverseList = ReverseList(head.next);
             head.next.next = head;
             head.next = null;
             return reverseList;
         }
     }
   #+end_src 
   - [[ilink18][递归考虑的4点]]
     - 父子问题抽象建模
       - 父问题： ~head --> n(1) -x> n(k-1) --> n(k)~ -> ~n(k) --> n(k-1) -x> n(1) *-->* head~ ，即 ~ReverseList(head)~ 
       - 子问题： ~head --> n(1) -x> n(k-1) --> n(k)~ -> ~n(k) --> n(k-1) -x> n(1) *<--* head~ ，即 ~ReverseList(head.next)~ 
     - *base*: ~if (head == null || head.next == null) return head~ 
     - 父子问题答案的 *连贯依赖定式* ：父答案 = 子答案 + (~head~ --> ~n(1)~ -> ~n(1)~ --> ~head~)
       - ~head.next.next = head~ + ~head.next = null~ 
     - *复杂度可接受*
       - $O(n)$
       - $O(n)$ 
*** Question:                                                     :QUESTIONS:
    - [ ] 递归空间复杂度分析？
* 25 合并两个排序的链表                                                :LIST:
** 新建一条列表 Non-destructive
*** 迭代                                                          :ITERATIVE:
    #+begin_src java :classname 
      /*
        public class ListNode {
        int val;
        ListNode next = null;

        ListNode(int val) {
        this.val = val;
        }
        }*/
      public class Solution {
          public ListNode Merge(ListNode list1,ListNode list2) {
              if (list1 == null) return list2;
              if (list2 == null) return list1;
              ListNode head = new ListNode(0), n = head, n1 = list1, n2 = list2;
              while (n1 != null && n2 != null) {
                  int value;
                  if (n1.val <= n2.val) {
                      value = n1.val;
                      n1 = n1.next;
                  } else {
                      value = n2.val;
                      n2 = n2.next;
                  }
                  n.next = new ListNode(value);
                  n = n.next;
              }
              n.next = n1 == null ? n2 : n1;
              return head.next;
          }
      }
    #+end_src 
    - 保持 ~list1~ 和 ~list2~ 不变，新建一条合并后的列表
      - 维持1个头节点 ~head~ ，1个插入节点 ~n~ ，2个遍历节点 ~n1~ 和 ~n2~ 分别对应 ~list1~ 和 ~list2~
    - 极端情况：
      #+begin_src java :classname 
        if (list1 == null) return list2;
        if (list2 == null) return list1;
      #+end_src 
    - ~n1 != null && n2 != null~ 继续遍历 --> ~n1 == null || n2 == null~ 时直接添加 ~n.next = n1 == null ? n2 : n1~
    - 复杂度
      - $O(n)$
      - $O(1)$ 
*** 递归                                                          :RECURSIVE:
    #+begin_src java :classname 
      /*
        public class ListNode {
        int val;
        ListNode next = null;

        ListNode(int val) {
        this.val = val;
        }
        }*/
      public class Solution {
          public ListNode Merge(ListNode list1,ListNode list2) {
              if (list1 == null) return list2;
              if (list2 == null) return list1;
              ListNode head;
              if (list1.val <= list2.val) {
                  head = new ListNode(list1.val);
                  head.next = Merge(list1.next, list2);
              } else {
                  head = new ListNode(list2.val);
                  head.next = Merge(list1, list2.next);
              }
              return head;
          }
      }
    #+end_src 
    - [[ilink18][递归考虑的4点]]
      - 父子问题抽象建模
        - 父问题： ~n(1) --> n(2)~ + ~n(3) --> n(4)~ -> ~n(1) --> n(2) --> n(3) --> n(4)~
        - 子问题： ~n(2)~ + ~n(3) --> n(4)~ -> ~n(2) --> n(3) --> n(4)~
      - *Base*:
        #+begin_src java :classname 
          if (list1 == null) return list2;
          if (list2 == null) return list1;
        #+end_src 
      - 父子答案 的 *连贯依赖定式* ：父答案 = 子答案 + (~new head~ + ~n(1) --> n(2)~ -> ~head --> n(1) --> n(2)~)
        #+begin_src java :classname 
          head = new ListNode(list1.val);
          head.next = Merge(list1.next, list2);
        #+end_src 
      - *复杂度可接受*
        - $O(n)$
        - $O(n)$ 
** 插入到某一条列表 Destructive
*** 迭代                                                          :ITERATIVE:
    #+begin_src java :classname 
      /*
        public class ListNode {
        int val;
        ListNode next = null;

        ListNode(int val) {
        this.val = val;
        }
        }*/
      public class Solution {
          public ListNode Merge(ListNode list1,ListNode list2) {
              if (list1 == null) return list2;
              if (list2 == null) return list1;
              ListNode preNode, insertNode, cutNode;
              preNode = null;
              insertNode = list1.val <= list2.val ? list1 : list2;
              cutNode = insertNode == list1 ? list2 : list1;
              while (cutNode != null) {
                  if (insertNode == null) {
                      preNode.next = cutNode;
                      break;
                  }
                  if (insertNode.val <= cutNode.val) {
                      preNode = insertNode;
                      insertNode = insertNode.next;
                  } else {
                      ListNode nextcutNode = cutNode.next;
                      cutNode.next = insertNode;
                      preNode.next = cutNode;
                      preNode = cutNode;
                      cutNode = nextcutNode;
                  }
              }
              return list1.val <= list2.val ? list1 : list2;
          }
      }
    #+end_src 
    - 以第1个节点较小的 ~list~ 为 *并入列表* ，较大的为 *拆分列表* ，依次从拆分列表 *拆除节点* 插入并入列表 *合适的位置*
      - *并入列表* 维持 *插入位置前后2个节点* ~preNode --> insertNode~ ， *拆分列表* 维持 *1个被拆节点* ~cutNode~ --> 将 ~cutNode~ 插入到合适的 ~preNode~ 和 ~insertNode~ 之间　--> ~preNode --> cutNode --> insertNode~
        - 位置不合适 -> 维持 ~cutNode~ ，更新 ~preNode --> insertNode~ 找合适的位置
        - 位置合适 -> 插入 ~preNode --> cutNode --> insertNode~ ，维持 ~insertNode~ ，更新 ~preNode~ 和 ~cutNode~ 
      - 直到 *拆分列表为空* 或到 *并入列表* 尾都没有 *合适的位置
    - 初始化
      #+begin_src java :classname 
        preNode = null;
        insertNode = list1.val <= list2.val ? list1 : list2;
        cutNode = insertNode == list1 ? list2 : list1;
      #+end_src 
    - 插入位置不合适
      #+begin_src java :classname 
        preNode = insertNode;
        insertNode = insertNode.next;
      #+end_src 
    - 插入位置合适
      #+begin_src java :classname 
        ListNode nextcutNode = cutNode.next;
        cutNode.next = insertNode;
        preNode.next = cutNode;
        preNode = cutNode;
        cutNode = nextcutNode;
      #+end_src
    - 结束
      #+begin_src java :classname 
        while (cutNode != null) {
            if (insertNode == null) {
                preNode.next = cutNode;
                break;
            }
            ...
        }
      #+end_src
    - 复杂度
      - $O(n)$
      - $O(1)$ 
*** 递归                                                          :RECURSIVE:
    #+begin_src java :classname 
      /*
        public class ListNode {
        int val;
        ListNode next = null;

        ListNode(int val) {
        this.val = val;
        }
        }*/
      public class Solution {
          public ListNode Merge(ListNode list1,ListNode list2) {
              if (list1 == null) return list2;
              if (list2 == null) return list1;
              ListNode head;
              if (list1.val <= list2.val) {
                  head = list1;   
                  head.next = Merge(list1.next, list2);
              }
              else {
                  head = list2;
                  head.next = Merge(list1, list2.next);
              }
              return head;
          }
      }
    #+end_src 
    - 与 Non-destructive 的递归关键差别在于 ~head = list1~ vs ~head = new ListNode(list1.val)~ 
** Question:                                                      :QUESTIONS:
   - [ ] 关于递归的空间复杂度分析？
* 26 树的子结构
** 递归                                                           :RECURSIVE:
   #+begin_src java :classname 
     /**
        public class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        public TreeNode(int val) {
        this.val = val;

        }

        }
     ,*/
     public class Solution {
         public boolean HasSubtree(TreeNode root1,TreeNode root2) {
             if (root1 == null || root2 == null) return false;
             // if      (root1.val > root2.val) return HasSubtree(root1.left, root2);
             // else if (root1.val < root2.val) return HasSubtree(root1.right, root2);
             // else return isSubtree(root1, root2);
             return isSubtree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);
            }

         private boolean isSubtree(TreeNode root1, TreeNode root2) {
             if (root2 == null) return true;
             if (root1 == null) return false;
             if (root1.val != root2.val || !isSubtree(root1.left, root2.left) || !isSubtree(root1.right, root2.right)) return false;
             return true;
         }
     }
   #+end_src 
   - *树* 优先考虑 *递归* 
     - 父子问题
       - B树是不是A树的子结构
       - B树是不是A *左（右)子树* 的子结构
     - *Base*: ~if (root1 == null || root2 == null) return false~
     - 父答案 = *A树的根节点* 是不是 *子结构的根节点* || 子答案
       - ~return isSubtree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2)~
       - ~isSubtree~
         - 父子问题
           - *A树的根节点* 是不是 *子结构的根节点*
           - *A树的子节点* 是不是 *B树子树对应子结构的根节点*
         - *Base*:
           #+begin_src java :classname 
             if (root2 == null) return true;
             if (root1 == null) return false; // if (root1 == null && root2 != null)
           #+end_src
         - 父答案 = (A树根节点值 == B树根节点值) && 子答案
           - ~if (root1.val != root2.val || !isSubtree(root1.left, root2.left) || !isSubtree(root1.right, root2.right)) return false~ 
         - *复杂度可接受*
           - 
           - 
     - *复杂度可接受*
       - 
       - 
** 迭代                                                :UNRESOLVED:ITERATIVE:
** Question:                                                      :QUESTIONS:
   - [ ] 递归的复杂度分析？
   - [ ] 迭代如何实现？
* 27 二叉树的镜像
** 递归                                                           :RECURSIVE:
   #+begin_src java :classname 
     public class Solution {
         public void Mirror(TreeNode root) {
             if (root == null) return;
             Mirror(root.left);
             Mirror(root.right);
             TreeNode tempLeft = root.left;
             root.left = root.right;
             root.right = tempLeft;
         }
     }
   #+end_src 
   - *树* 优先考虑 *递归*
     - 父子问题
       - 树的镜像
       - 子树的镜像
     - *Base*: ~if (root == null) return~
     - 父答案 = 子答案 + 交换根节点的左右子节点
       #+begin_src java :classname 
         Mirror(root.left);
         Mirror(root.right);
         TreeNode tempLeft = root.left;
         root.left = root.right;
         root.right = tempLeft;
       #+end_src
       - 交换左右子节点再左右子树镜像 *顺序可换* ，实际对应的操作就是 *树遍历*
         - ~mirror --> swap~ 更符合 *递归的父子问题思想*, 实际上就是 *从下往上遍历* 交换子节点
         - ~swap --> mirror~ 直觉上不符合 *父子问题思想*, 但实际效果一样，即 *从上往下遍历* 交换子节点
     - *复杂度可接受*
       - $O(n)$
       - $O(n)$
** 迭代（本题扩展） <<ilink30>>                             :EXTRA:ITERATIVE:
   #+begin_src java :classname 
     import java.util.*;

     public class Solution {
         public void Mirror(TreeNode root) {
             if (root == null) return;
             Queue<TreeNode> toSwap = new LinkedList<>();
             // Stack<TreeNode> toSwap = new Stack<>();
             toSwap.offer(root);
             // toSwap.push(root);
             TreeNode curr, temp;
             while (!toSwap.isEmpty()) {
                 int nodes = toSwap.size();
                 for (int i = 0; i < nodes; i++) {
                     curr = toSwap.poll();
                     // curr = toSwap.pop();
                     temp = curr.left;
                     curr.left = curr.right;
                     curr.right = temp;
                     if (curr.left != null) toSwap.offer(curr.left);
                     // if (curr.left != null) toSwap.push(curr.left);
                     if (curr.right != null) toSwap.offer(curr.right);
                     // if (curr.right != null) toSwap.push(curr.right);
                 }
             }
         }
     }
   #+end_src 
   - 与递归中的 *从上往下or从下往上遍历* 交换子节点不同 -> *内外循环* 实现 *层序遍历* 交换子节点
     - 外循环需要从 *顶层循环到底层* ，共循环 *层数* 次 -> 转化为判断是否还有 *未交换子节点的节点*
     - 内循环需要 *从左往右交换该层节点* 子节点，并把 *下层子节点* 加入 *未交换子节点的节点* 以 *配合* 外循环完成从 *顶层循环到底层*
     - 使用 ~Queue~ 或 ~Stack~ 实现内外循环的配合 <<ilink19>>
       - ~Queue~ *FIFO BFS*: ~poll~ 方向与 ~offer~ *一致*, 均为 *层序* 或 *对称层序* 遍历，取决于 ~offer~ 方向
       - ~Stack~ *LIFO DFS*: ~pop~ 方向与 ~push~ *相反*, 对应 *前序* 和 *对称前序* 遍历，取决于 ~push~ 方向
   - 极端情况: ~if (root == null) return~
   - *层序* 遍历 *本层* 节点: *交换+存储* 子节点
     #+begin_src java :classname 
       int nodes = toSwap.size();
       for (int i = 0; i < nodes; i++) {
           curr = toSwap.poll();
           // curr = toSwap.pop();
           temp = curr.left;
           curr.left = curr.right;
           curr.right = temp;
           if (curr.left != null) toSwap.offer(curr.left);
           // if (curr.left != null) toSwap.push(curr.left);
           if (curr.right != null) toSwap.offer(curr.right);
           // if (curr.right != null) toSwap.push(curr.right);
       }
     #+end_src 
   - 有关 ~LinkedList~, ~Queue~ 和 ~Stack~ 引发的 *接口和类继承关系和实现* 思考 <<elink5>>
     - ~interface extends interface~: ~Iterable~ --> ~Collection~ --> ~List~ 和 (~Queue~ --> ~Deque~) 
     - ~class implements interface~
       - ~class LinkedList<E> implements List<E>, Deque<E>~: ~public abstract class AbstractCollection<E> extends Object implements Collection<E>~ --> ~public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E>~ --> ~public abstract class AbstractSequentialList<E> extends AbstractList<E>~ --> ~public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable~
       - ~class Stack<E> implements List<E>~: ~public class Vector<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable~ --> ~public class Stack<E> extends Vector<E>~ 
     - ~Queue~ 方法对比
       #+DOWNLOADED: screenshot @ 2020-01-01 23:01:36
       [[file:pictures/27_二叉树的镜像/2020-01-01_23-01-36_screenshot.png]]
     - ~Deque~ 方法对比
       #+DOWNLOADED: screenshot @ 2020-01-01 23:03:31
       [[file:pictures/27_二叉树的镜像/2020-01-01_23-03-31_screenshot.png]]
       - *FIFO* -> ~Queue~ 
         #+DOWNLOADED: screenshot @ 2020-01-01 23:04:41
         [[file:pictures/27_二叉树的镜像/2020-01-01_23-04-41_screenshot.png]]
       - *LIFO* -> ~Stack~
         #+DOWNLOADED: screenshot @ 2020-01-01 23:07:00
         [[file:pictures/27_二叉树的镜像/2020-01-01_23-07-00_screenshot.png]]
   - 复杂度
     - $O(n)$
     - $O(n)$
** Question:                                                      :QUESTIONS:
   - [ ] 递归和迭代的空间复杂度分析
* 28 对称的二叉树
** 递归                                                           :RECURSIVE:
*** 借助二叉树的镜像以及子结构
    #+begin_src java :classname 
      public class Solution {
          boolean isSymmetrical(TreeNode pRoot) {
              if (pRoot == null) return true;
              TreeNode dup = dupTree(pRoot);
              Mirror(pRoot);
              return isSubtree(pRoot, dup) && isSubtree(dup, pRoot);
          }

          private void Mirror(TreeNode root) {
              if (root == null) return;
              Mirror(root.left);
              Mirror(root.right);
              TreeNode tempLeft = root.left;
              root.left = root.right;
              root.right = tempLeft;
          }

          private TreeNode dupTree(TreeNode root) {
              if (root != null) {
                  TreeNode p = new TreeNode(root.val);
                  p.left = dupTree(root.left);
                  p.right = dupTree(root.right);
                  root = p;
              }
              return root;
          }

          private boolean isSubtree(TreeNode root1, TreeNode root2) {
              if (root2 == null) return true;
              if (root1 == null) return false;
              if (root1.val != root2.val || !isSubtree(root1.left, root2.left) || !isSubtree(root1.right, root2.right)) return false;
              return true;
          }
      }
    #+end_src 
    - 对称的二叉树 -> 其与其镜像 *互为子结构*
    - *递归* 复制二叉树
      - 父子问题
        - 复制A树
        - 复制A树的子树
      - *Base*: ~root == null~
      - 父答案 = 子答案 + 连接 *复制的根节点* 和 *复制的子树*
        #+begin_src java :classname 
          TreeNode p = new TreeNode(root.val);
          p.left = dupTree(root.left);
          p.right = dupTree(root.right);
          root = p;
        #+end_src 
      - *复杂度可接受*
        - $O(n)$
        - $O(n)$
    - 极端情况: ~if (pRoot == null) return true~ 
    - *互为子结构*: ~return isSubtree(pRoot, dup) && isSubtree(dup, pRoot)~
*** 遍历检查
    #+begin_src java :classname 
      public class Solution {
          boolean isSymmetrical(TreeNode pRoot) {
              if (pRoot == null) return true;
              return Sym(pRoot.left, pRoot.right);
              // return Sym(pRoot, pRoot);
          }

          private boolean Sym(TreeNode left, TreeNode right) {
              if (left == null && right == null) return true;
              if (left == null || right == null) return false;
              return left.val == right.val && Sym(left.left, right.right) && Sym(left.right, right.left);
          }
      }
    #+end_src 
    - 对称树 -> *根节点为空* 或 *左右子树互为对称*
      - *递归* 判断两颗树对称，也可以理解为对 *左子树前序遍历* ，对 *右子树对称前序遍历* ，判断遍历 *节点值是否都相等*
        - 父子问题
          - A树和B树对称
          - A树左子树和B树右子树对称，A树右子树和B树左子树对称
        - *Base*:
          #+begin_src java :classname 
            if (left == null && right == null) return true;
            if (left == null || right == null) return false;
          #+end_src
        - 父答案 = 子答案 + A树与B树根节点值相等
          - ~return left.val == right.val && Sym(left.left, right.right) && Sym(left.right, right.left)~ 
        - 复杂度可接受
          - $O(n)$
          - 
** 迭代                                                           :ITERATIVE:
   - 不排除 ~null~ 
     #+begin_src java :classname 
       import java.util.*;

       public class Solution {
           boolean isSymmetrical(TreeNode pRoot) {
               if (pRoot == null) return true;
               // Stack<TreeNode> nodes = new Stack<>();
               Queue<TreeNode> nodes = new LinkedList<>();
               // nodes.push(pRoot.left);
               // nodes.push(pRoot.right);
               nodes.offer(pRoot.left);
               nodes.offer(pRoot.right);
               TreeNode side1, side2;
               while(!nodes.isEmpty()) {
                   // side1 = nodes.pop();
                   // side2 = nodes.pop();
                   side1 = nodes.poll();
                   side2 = nodes.poll();
                   if (side1 == null && side2 == null) continue;
                   if (side1 == null || side2 == null) return false;
                   if (side1.val != side2.val) return false;
                   // nodes.push(side1.left);
                   // nodes.push(side2.right);
                   // nodes.push(side1.right);
                   // nodes.push(side2.left);
                   nodes.offer(side1.left);
                   nodes.offer(side2.right);
                   nodes.offer(side1.right);
                   nodes.offer(side2.left);
               }
               return true;
           }
       }
     #+end_src
     - ~Stack~ + 迭代 *DFS* 或 ~Queue~ + 迭代 *BFS* -> 对树的 *[[ilink19][迭代遍历]]* 往往借助 ~Stack~ 和 ~Queue~ 
       - 循环: 成对 *取出一组* 对称位置 --> 对称且 *不为空* --> 成对 *存储两组* 子树对称位置
         - 遍历方向 *从上到下*, 对称优先 *左右*, 取决于 *初始* ~pRoot.left~ 和 ~pRoot.right~ 的 *存储顺序* 以及 *子树对称位置的存储顺序*
       - 不排除 ~null~ 存入 ~Stack~, 当取出成对 ~null~ 时需要 *继续遍历* 直到 ~nodes.isEmpty()~ 
     - 对称位置 *均为空*: ~if (side1 == null && side2 == null) continue~
     - 复杂度
       - $O(n)$
       - $O(n)$
   - 排除 ~null~ 
     #+begin_src java :classname 
       import java.util.Stack;
  
       public class Solution {
           boolean isSymmetrical(TreeNode pRoot) {
               if (pRoot == null) return true;
               Stack<TreeNode> nodes = new Stack<>();
               if (pRoot.left == null && pRoot.right == null) return true;
               if (pRoot.left == null || pRoot.right == null) return false;
               nodes.push(pRoot.left);
               nodes.push(pRoot.right);
               TreeNode side1, side2;
               while(!nodes.isEmpty()) {
                   side1 = nodes.pop();
                   side2 = nodes.pop();
                   if (side1.val != side2.val) return false;
                   if (side1.left != null && side2.right != null) {
                       nodes.push(side1.left);
                       nodes.push(side2.right);
                   }
                   if (side1.left != null && side2.right == null) return false;
                   if (side1.left == null && side2.right != null) return false;
                   if (side1.right != null && side2.left != null) {
                       nodes.push(side1.right);
                       nodes.push(side2.left);
                   }
                   if (side1.right != null && side2.left == null) return false;
                   if (side1.right == null && side2.left != null) return false;
               }
               return true;
           }
       }
     #+end_src
     - 保证 ~Stack~ 里存的都是 *不为空的对称节点*, 对于以 ~!nodes.isEmpty()~ 为 *遍历终止条件* 更好理解一点
** Question:                                                      :QUESTIONS:
   - [ ] 递归和迭代的空间复杂度分析？
* 29 顺时针打印矩阵
** 迭代
*** 以圈为单位
    - 不计算好圈数
      #+begin_src java :classname 
        import java.util.ArrayList;

        public class Solution{
            private ArrayList<Integer> list = new ArrayList<>();
            public ArrayList<Integer> printMatrix(int [][] matrix) {
                if (matrix == null || matrix.length < 1 || matrix[0].length < 1) return list;
                int rows = matrix.length, cols = matrix[0].length, start = 0;
                while (rows > 2*start && cols > 2*start) {
                    printCircle(matrix, rows, cols, start);
                    start += 1;
                }
                return list;
            }

            private void printCircle(int[][] matrix, int rows, int cols, int start) {
                for (int col = start; col < cols-start; col++) {
                    list.add(matrix[start][col]);
                }
                for (int row = start+1; row < rows-start; row++) {
                    list.add(matrix[row][cols-start-1]);
                }
                for (int col = cols-start-2; col >= start; col--) {
                    if (rows-start-1 <= start) break;
                    list.add(matrix[rows-start-1][col]);
                }
                for (int row = rows-start-2; row > start; row--) {
                    if (cols-start-1 <= start) break;
                    list.add(matrix[row][start]);
                }
            }
        }
      #+end_src
      - 以圈为单位，每圈按序打印 *上右下左*
        - 每打印一圈 ~rows -= 2~ 和 ~cols -= 2~, 直到 ~<= 0~, 至少一圈（一行或一列）
        - 每行每列 *直接直觉打印到头*: 123 --> 69 --> 87 --> 4, 而不是 12 --> 36 --> 98 --> 74, 第一种更 *直接直观*, 看似不太规整但能包含 *一行or一列*; 第二种看似规整，但 *无法包含一行or一列*
          - 打印 *对称* 方向时需要判断是否 *重合* （重复）
      - 极端情况: ~if (matrix == null || matrix.length < 1 || matrix[0].length < 1) return list~
      - 循环条件: ~while (rows > 2*start && cols > 2*start)~
      - 上 --> 右 --> 下 --> 左
        #+begin_src java :classname 
          private void printCircle(int[][] matrix, int rows, int cols, int start) {
              for (int col = start; col < cols-start; col++) {
                  list.add(matrix[start][col]);
              }
              for (int row = start+1; row < rows-start; row++) {
                  list.add(matrix[row][cols-start-1]);
              }
              for (int col = cols-start-2; col >= start; col--) {
                  if (rows-start-1 <= start) break;
                  list.add(matrix[rows-start-1][col]);
              }
              for (int row = rows-start-2; row > start; row--) {
                  if (cols-start-1 <= start) break;
                  list.add(matrix[row][start]);
              }
          }
        #+end_src
        - *对称* 时判断 *重合*
          - ~if (rows-start-1 <= start) break~
          - ~if (cols-start-1 <= start) break~ 
      - 复杂度
        - $O(n)$
        - $O(n)$
    - 计算好圈数
      #+begin_src java :classname 
        import java.util.ArrayList;
        public class Solution {
            public ArrayList<Integer> printMatrix(int[][] matrix) {
                ArrayList<Integer> list = new ArrayList<>();
                if (matrix == null || matrix.length < 1 || matrix[0].length < 1) return list;
                int rows = matrix.length, cols = matrix[0].length;
                int circles = (Math.min(rows, cols)-1)/2 + 1;
                for (int cir = 0; cir < circles; cir++) {
                    for (int col = cir; col < cols-cir; col++) {
                        list.add(matrix[cir][col]);
                    }
                    for (int row = cir+1; row < rows-cir; row++) {
                        list.add(matrix[row][cols-cir-1]);
                    }
                    for (int col = cols-cir-2; col >= cir; col--) {
                        if (rows-cir-1 <= cir) break;
                        list.add(matrix[rows-cir-1][col]);
                    }
                    for (int row = rows-cir-2; row > cir; row--) {
                        if (cols-cir-1 <= cir) break;
                        list.add(matrix[row][cir]);
                    }
                }
                return list;
            }
        }
      #+end_src
      - 实际 *循环圈数* 可计算: ~int circles = (Math.min(rows, cols)-1)/2 + 1~ 
*** 利用标记数组
    #+begin_src java :classname 
      import java.util.ArrayList;
      public class Solution {
          private static final int[] dx = {0, 1, 0, -1};
          private static final int[] dy = {1, 0, -1, 0};
          public ArrayList<Integer> printMatrix(int[][] matrix) {
              ArrayList<Integer> list = new ArrayList<>();
              if (matrix == null || matrix.length < 1 || matrix[0].length < 1) return list;
              int row = matrix.length, col = matrix[0].length;
              int x = 0, y = 0, dir = 0;
              boolean[][] visited = new boolean[row][col];
              while (x >= 0 && x < row && y >= 0 && y < col && !visited[x][y]) {
                  list.add(matrix[x][y]);
                  visited[x][y] = true;
                  int nX = x + dx[dir];
                  int nY = y + dy[dir];
                  while (nX >= 0 && nX < row && nY >=0 && nY < col && !visited[nX][nY]) {
                      x += dx[dir];
                      y += dy[dir];
                      list.add(matrix[x][y]);
                      visited[x][y] = true;
                      nX = x + dx[dir];
                      nY = y + dy[dir];
                  }
                  dir = (dir+1) % 4;
                  x += dx[dir];
                  y += dy[dir];
              }
              return list;
          }
      }
    #+end_src 
    - 打印并标记， *到达边界或遇到已标记位置* 时改变方向，直到 *改变方向后* 仍遇到 *已标记位置*
      - 两层循环： *外层* 负责 *改变方向* 并 *标记新方向* 上的 *第一个未标记位置*, *内层* 负责在该方向上标记直到 *越界或标记位置*
        - 维持标记数组 ~visited~
        - 方向变化选择 *唯一* 且 *周期为4*
          - 维持 *1个周期* 方向变量 ~dir~: 向右 --> 向下 --> 向左 --> 向上
          - 二维 -> 维持 *2个方向常量* ~dx~, ~dy~ 
    - 循环条件
      - 外层判断 *变向后初始* 位置: ~while (x >= 0 && x < row && y >= 0 && y < col && !visited[x][y])~ 
      - 内曾判断 *沿向往后* 位置: ~while (nX >= 0 && nX < row && nY >=0 && nY < col && !visited[nX][nY])~ 
    - 方向相关
      - 方向 *常量*
        #+begin_src java :classname 
          private static final int[] dx = {0, 1, 0, -1};
          private static final int[] dy = {1, 0, -1, 0};
        #+end_src
      - 改变方向 *变量*: ~dir = (dir+1) % 4~
      - 沿着方向变量 ~dir~ *移动*
        #+begin_src java :classname 
          x += dx[dir];
          y += dy[dir];
        #+end_src 
    - 复杂度
      - $O(n)$
      - $O(n)$
*** 收缩矩阵边界
    #+begin_src java :classname 
      import java.util.ArrayList;
      public class Solution {
          public ArrayList<Integer> printMatrix(int[][] matrix) {
              ArrayList<Integer> list = new ArrayList<>();
              if (matrix == null || matrix.length < 1 || matrix[0].length < 1) return list;
              int up = 0, left = 0;
              int down = matrix.length - 1, right = matrix[0].length - 1;
              while(true) {
                  for (int col = left; col <= right; col++) {
                      list.add(matrix[up][col]);
                  }
                  up += 1;
                  if (up > down) break;

                  for (int row = up; row <= down; row++) {
                      list.add(matrix[row][right]);
                  }
                  right -= 1;
                  if (left > right) break;

                  for (int col = right; col >= left; col--) {
                      list.add(matrix[down][col]);
                  }
                  down -= 1;
                  if (up > down) break;

                  for (int row = down; row >= up; row--) {
                      list.add(matrix[row][left]);
                  }
                  left += 1;
                  if (left > right) break;
              }
              return list;
          }
      }
    #+end_src 
    - 顺时针打印: 第一行并 *更新* --> 最后一列并 *更新* --> 最后一行并 *更新* --> 第一列并 *更新*
      - 维持打印时 *不变量*: 第一 *行号* ~up~, ... ~right~, ~down~, ~left~
      - 循环打印并 *更新不变量* 直到 *不变量破坏约束*: ~up <= down~, ~left <= right~ 
    - 复杂度
      - $O(n)$
      - $O(n)$
** 递归                                                          :UNRESOLVED:
** Python                                                        :UNRESOLVED:
*** 用 ~pop~, 应该类似与收缩边界
    #+begin_src python :results output
      class Solution:
 
          def printMatrix(self, matrix):
              res = []
              while matrix:
                  res += matrix.pop(0)
                  if matrix and matrix[0]:
                      for row in matrix:
                          res.append(row.pop())
                  if matrix:
                      res += matrix.pop()[::-1]
                  if matrix and matrix[0]:
                      for row in matrix[::-1]:
                          res.append(row.pop(0))
              return res
    #+end_src 
*** 递归
    #+begin_src python :results output
      class Solution:
          def printMatrix(self, matrix):
              if matrix:
                  top_row=list(matrix[0])
                  array=list(zip(*matrix[1:]))
                  array.reverse()
                  return top_row+self.printMatrix(array)
              else:
                  return []#保证递归的结束
    #+end_src 
** Question:                                                      :QUESTIONS:
   - [ ] Java能否类似python递归？
* 30 包含min函数的栈 <<ilink26>>
** 辅助栈记录历史最小值
   - 未优化辅助栈空间
     #+begin_src java :classname 
       import java.util.Stack;

       public class Solution {
           private Stack<Integer> data = new Stack<>();
           private Stack<Integer> min = new Stack<>();

           public void push(int node) {
               data.push(node);
               if (min.empty() || node < min.peek()) min.push(node);
               else min.push(min.peek());
           }

           public void pop() {
               if (!data.empty()) data.pop();
               if (!min.empty()) min.pop();
           }

           public int top() {
               return data.peek();
           }

           public int min() {
               return min.peek();
           }
       }
     #+end_src
     - 栈结构 + 取最小复杂度 $O(1)$ -> 维持保存最小的变量 -> 最小 *出栈后更新* 最小 -> 维持 *辅助栈* 保存 *历史最小*
     - 辅助栈保存 *历史最小*
       #+begin_src java :classname 
         if (min.empty() || node < min.peek()) min.push(node);
         else min.push(min.peek());
       #+end_src
     - 复杂度
       - $O(n)$
       - $O(n)$
   - 优化辅助栈空间
     #+begin_src java :classname 
       import java.util.Stack;

       public class Solution {
           private Stack<Integer> data = new Stack<>();
           private Stack<Integer> min = new Stack<>();

           public void push(int node) {
               data.push(node);
               if (min.empty() || node < min.peek()) min.push(node);
           }

           public void pop() {
               if (!data.empty()) {
                   int temp = data.pop();
                   if (data.empty() || temp < data.peek()) min.pop();
               }
           }

           public int top() {
               return data.peek();
           }

           public int min() {
               return min.peek();
           }
       }
     #+end_src
     - *辅助栈* 仅存储 *更新的最小*: ~if (min.empty() || node < min.peek()) min.push(node)~
     - 辅助栈仅在 *相应最小* 在 *数据栈出栈时出栈*: ~if (data.empty() || temp < data.peek()) min.pop()~ 
     - 复杂度
       - $O(n)$
       - 最坏仍是 $O(n)$, 但比未优化的好
** 辅助值记录当前值
   #+begin_src java :classname 
     import java.util.Stack;

     public class Solution {
         private Stack<Integer> data = new Stack<>();
         private int min;

         public void push(int node) {
             if (data.empty()) {
                 min = node;
             }
             data.push(node-min);
             if (node < min) {
                 min = node;
             }
         }

         public void pop() {
             if (!data.empty()) {
                 if (data.peek() < 0) min -= data.peek();
                 data.pop();
             }
         }

         public int top() {
             return data.peek() < 0 ? min : min+data.peek();
         }

         public int min() {
             return min;
         }
     }
   #+end_src 
   - 利用数据栈中 *冗余信息*, 维持1个 *冗余栈* 和 *最小值*, 利用 *冗余值+冗余值符号+最小值* 完成 *存储冗余+更新最小值+恢复栈顶数据*
     - 冗余值: *当前数据* 与 *之前最小值* 之差
     - 冗余值符号: *当前数据* 与 *之前最小值* 大小关系
     - 最小值: 由出栈和入栈 *冗余值符号* 决定是否 *更新* 最小值
     - 栈顶数据: 由 *栈顶冗余+栈顶冗余符号+当前最小值* 恢复
   - ~push~ 冗余入栈+更新最小值
     #+begin_src java :classname 
       data.push(node-min);
       if (node < min) {
           min = node;
       }
     #+end_src 
   - ~pop~ 冗余出栈+更新最小值
     #+begin_src java :classname 
       if (!data.empty()) {
           if (data.peek() < 0) min -= data.peek();
           data.pop();
       }
     #+end_src 
   - ~top~ 恢复栈顶数据:
     #+begin_src java :classname 
       return data.peek() < 0 ? min : min+data.peek();
     #+end_src 
   - 复杂度
     - $O(n)$
     - $O(1)$
* 31 栈的压入，弹出序列
** 递归
*** 以第一个 *出栈* 元素为准将 *入栈* 数组分组
    #+begin_src java :classname 
      import java.util.*;

      public class Solution {
          public boolean IsPopOrder(int[] pushA,int[] popA) {
              if (pushA == null || popA == null || pushA.length != popA.length) return false;
              if (pushA.length == 0) return true;
              if (pushA.length == 1) return pushA[0] == popA[0];
              int first = popA[0], index = -1;
              for (int i : pushA) {
                  index += 1;
                  if (i == first) break;
              }
              if (index == -1) return false;
              int[] left = Arrays.copyOfRange(pushA, 0, index);
              int[] right = Arrays.copyOfRange(pushA, index+1, pushA.length);
              int leftEnd = index, rightStart = index + 1;
              if (index != 0 && popA[1] != left[index-1]) {
                  leftEnd = popA.length - 1;
                  rightStart = 1;
              }
              int[] rightInpopA = Arrays.copyOfRange(popA, rightStart, rightStart+right.length);
              return IsPopOrder(right, rightInpopA) && reverse(left, popA, leftEnd);
              // int leftStart = leftEnd + 1 - left.length;
              // int[] leftInpopA = Arrays.copyOfRange(popA, leftStart, leftStart+left.length);
              // return IsPopOrder(right, rightInpopA) && IsPopOrder(left, leftInpopA);
          }

          private boolean reverse(int[] a, int[] b, int index) {
              if (index != 0) {
                  for (int i = 0; i < a.length; i++) {
                      if (a[i] != b[index-i]) return false;
                  }
              }
              return true;
          }
      }
    #+end_src
    - 根据 *第一个出栈* 在 *入栈数组中的位置* 将入栈数组分为两部分: *已入栈* + *未入栈* --> 对应 *分别* 验证 *已入栈* 及其 *出栈部分* 和 *未入栈* 及其 *出栈部分*
      - 父子问题
        - 验证 *入栈数组* 和对应 *出栈数组*
        - 验证 *未入栈* 及其 *出栈部分*
      - *Base:*
        #+begin_src java :classname 
          if (pushA == null || popA == null || pushA.length != popA.length) return false;
          if (pushA.length == 0) return true;
          if (pushA.length == 1) return pushA[0] == popA[0];
        #+end_src
      - 父答案 = 子答案 + 验证 *已入栈* 及其 *出栈部分*
        - ~return IsPopOrder(right, rightInpopA) && reverse(left, popA, leftEnd)~ 
      - *复杂度可接受*
        - $O(n)$
        - 
    - 定位 *已入栈* 及其 *出栈部分* 和 *未入栈* 及其 *出栈部分*
      #+begin_src java :classname 
        int first = popA[0], index = -1;
        for (int i : pushA) {
            index += 1;
            if (i == first) break;
        }
        if (index == -1) return false;
        int[] left = Arrays.copyOfRange(pushA, 0, index);
        int[] right = Arrays.copyOfRange(pushA, index+1, pushA.length);
        int leftEnd = index, rightStart = index + 1;
        if (index != 0 && popA[1] != left[index-1]) {
            leftEnd = popA.length - 1;
            rightStart = 1;
        }
        int[] rightInpopA = Arrays.copyOfRange(popA, rightStart, rightStart+right.length);
      #+end_src
      - 入栈数组中找不到第一个出栈: ~if (index == -1) return false~
      - *已入栈* 及其 *出栈部分*: ~int[] left = Arrays.copyOfRange(pushA, 0, index)~ + ~leftEnd~
      - *未入栈* 及其 *出栈部分*: ~int[] right = Arrays.copyOfRange(pushA, index+1, pushA.length)~ + ~int[] rightInpopA = Arrays.copyOfRange(popA, rightStart, rightStart+right.length)~ 
    - *已入栈* 及其 *出栈部分* 的验证 *不是递归子问题*, 就是一个验证 *逆数组* 的问题， *不能* 用递归解决
      #+begin_src java :classname 
        private boolean reverse(int[] a, int[] b, int index) {
            if (index != 0) {
                for (int i = 0; i < a.length; i++) {
                    if (a[i] != b[index-i]) return false;
                }
            }
            return true;
        }
      #+end_src
    - ~Arrays.copyOfRange(T[] a, startIndex, endIndex)~ 包括 ~startIndex~, 排除 ~endIndex~, 返回数组长度为 ~endIndex-startIndex~ 
*** 以第一个 *入栈* 元素为准将 *出栈* 数组分组
    #+begin_src java :classname 
      import java.util.*;

      public class Solution {
          public boolean IsPopOrder(int[] pushA,int[] popA) {
              if (pushA == null || popA == null || pushA.length != popA.length) return false;
              int index = -1, length = pushA.length;
              if (length == 0) return true;
              if (length == 1) return pushA[0] == popA[0];
              for (int i : popA) {
                  index += 1;
                  if (i == pushA[0]) break;
              }
              if (index == -1) return false;
              int[] lpushA = Arrays.copyOfRange(pushA, 1, index+1);
              int[] rpushA = Arrays.copyOfRange(pushA, index+1, length);
              int[] lpopA = Arrays.copyOfRange(popA, 0, index);
              int[] rpopA = Arrays.copyOfRange(popA, index+1, length);
              return IsPopOrder(lpushA, lpopA) && IsPopOrder(rpushA, rpopA);
          }
      }
    #+end_src
    - 根据 *第一个入栈* 在 *出栈数组中的位置* 将出栈数组分为两部分: *已出栈* + *未出栈* --> 对应 *分别* 验证 *已出栈* 及其 *入栈部分* 和 *未出栈* 及其 *入栈部分* -> 具有 *对称性质* 的问题可以考虑其 *对称问题*
      - 父子问题
        - 验证 *出栈数组* 和对应 *入栈数组*
        - 验证 *已出栈* 及其 *入栈部分* 和 *未出栈* 及其 *入栈部分* 
      - *Base:*
        #+begin_src java :classname 
          if (pushA == null || popA == null || pushA.length != popA.length) return false;
          if (pushA.length == 0) return true;
          if (pushA.length == 1) return pushA[0] == popA[0];
        #+end_src
      - 父答案 = 子答案
        - ~return IsPopOrder(lpushA, lpopA) && IsPopOrder(rpushA, rpopA)~ 
      - *复杂度可接受*
        - $O(n)$
        - 
    - 定位 *已出栈* 及其 *入栈部分* 和 *未出栈* 及其 *入栈部分*
      #+begin_src java :classname 
        int[] lpushA = Arrays.copyOfRange(pushA, 1, index+1);
        int[] rpushA = Arrays.copyOfRange(pushA, index+1, length);
        int[] lpopA = Arrays.copyOfRange(popA, 0, index);
        int[] rpopA = Arrays.copyOfRange(popA, index+1, length);
      #+end_src
    - 两种思路的比较: *入栈验证出栈* 和 *出栈验证入栈*
*** Question:                                                     :QUESTIONS:
    - [ ] 空间复杂度分析
    - [ ] 两种思路的比较？相比而言第二种更清晰，本质原因是什么？
** 辅助栈
   #+begin_src java :classname 
     import java.util.*;

     public class Solution {
         public boolean IsPopOrder(int[] pushA,int[] popA) {
             if (pushA == null || popA == null || pushA.length != popA.length) return false;
             Stack<Integer> s = new Stack<>();
             int j = 0;
             for (int i = 0; i < pushA.length; i++) {
                 s.push(pushA[i]);
                 while (!s.empty() && s.peek() == popA[j]) {
                     s.pop();
                     j += 1;
                 }
             }
             return s.empty();
         }
     }
   #+end_src
   - *出栈顺序的多样性* 来源于 *入栈即出栈* 元素之后选择 *出栈* 还是 *入栈* -> 用辅助栈模拟过程先 *入栈* 直到 *入栈即出栈* 元素 --> 遍历 *入栈等待出栈* 元素 --> 继续 *入栈* 并寻找下一个 *入栈即出栈* 元素 -> 与栈相关可以考虑 *辅助栈*
   - 寻找 *入栈即出栈* 元素并遍历 *入栈等待出栈* 元素
     #+begin_src java :classname 
       int j = 0;
       for (int i = 0; i < pushA.length; i++) {
           s.push(pushA[i]);
           while (!s.isEmpty() && s.peek() == popA[j]) {
               s.pop();
               j += 1;
           }
       }
     #+end_src
   - 判断条件: ~return s.empty()~
     - 为空 -> 过程模拟成功
     - 不为空 -> 无法模拟此过程
   - 复杂度
     - $O(n)$
     - $O(n)$
   - ~Stack.empty()~ 或 ~Stack.isEmpty()~ (~Stack implements List~ + ~List.isEmpty()~)
* 32 从上往下打印二叉树
** 不分层
   #+begin_src java :classname 
     import java.util.*;
     /**
        public class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        public TreeNode(int val) {
        this.val = val;

        }

        }
     ,*/
     public class Solution {
         public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
             ArrayList<Integer> list = new ArrayList<>();
             if (root == null) return list;
             Queue<TreeNode> treeQue = new LinkedList<>();
             treeQue.offer(root);
             while (!treeQue.isEmpty()) {
                 TreeNode n = treeQue.poll();
                 list.add(n.val);
                 if (n.left != null) treeQue.offer(n.left);
                 if (n.right != null) treeQue.offer(n.right);
             }
             return list;
         }
     }
   #+end_src 
   - 图or树的 *BFS* 遍历往往借助 [[ilink19][Queue]]: 从上到下打印 -> 需要 *容器循环按序* 的存储未打印的节点
     - *本层先打印* 节点的子节点在 *下层也先打印* -> ~Queue~
     - 1个 ~Queue~ 打印节点的同时存储其子节点 *不会影响打印顺序* -> 只需要 *1个* ~Queue~
   - 极端情况: ~if (root == null) return list~
   - 复杂度
     - $O(n)$
     - $O(n)$
** 按层之字形
*** 两个 ~Stack~ 
    #+begin_src java :classname 
      import java.util.*;

      public class Solution {
          public ArrayList<ArrayList<Integer>> Print(TreeNode pRoot) {
              ArrayList<ArrayList<Integer>> list = new ArrayList<>();
              if (pRoot == null) return list;
              Stack<TreeNode> treeStack1 = new Stack<>();
              boolean lTor = true;
              treeStack1.push(pRoot);
              while (!treeStack1.isEmpty()) {
                  int nodes = treeStack1.size();
                  ArrayList<Integer> valList = new ArrayList<>();
                  Stack<TreeNode> treeStack2 = new Stack<>();
                  for (int i = 0; i < nodes; i++) {
                      TreeNode n = treeStack1.pop();
                      valList.add(n.val);
                      if (lTor) {
                          if (n.left != null) treeStack2.push(n.left);
                          if (n.right != null) treeStack2.push(n.right);
                      } else {
                          if (n.right != null) treeStack2.push(n.right);
                          if (n.left != null) treeStack2.push(n.left);
                      }
                  }
                  treeStack1 = treeStack2;
                  lTor = !lTor;
                  list.add(valList);
              }
              return list;
          }
      }
    #+end_src 
    - 从上到下 *之字形按层* 打印 -> 需要 *容器循环按序* 的存储未打印的节点
      - *之字形*: *本层后打印* 节点的子节点在 *下层先打印* -> ~Stack~
      - 1个 ~Stack~ 打印同时存储子节点会 *破坏顺序* -> 下层子节点存在 *辅助栈* + *打印栈* = *辅助栈*
    - 复杂度
      - $O(n)$
      - $O(n)$
*** ~LinkedList~ 
    #+begin_src java :classname 
      import java.util.*;

      public class Solution {
          public ArrayList<ArrayList<Integer>> Print(TreeNode pRoot) {
              ArrayList<ArrayList<Integer>> list = new ArrayList<>();
              if (pRoot == null) return list;
              LinkedList<TreeNode> treeList = new LinkedList<>();
              boolean lTor = true;
              treeList.add(pRoot);
              while (!treeList.isEmpty()) {
                  int nodes = treeList.size();
                  ArrayList<Integer> valList = new ArrayList<>();
                  for (int i = 0; i < nodes; i++) {
                      // TreeNode n = lTor ? treeList.removeFirst() : treeList.removeLast();
                      TreeNode n = lTor ? treeList.removeLast() : treeList.removeFirst();
                      valList.add(n.val);
                      if (lTor) {
                          // if (n.left != null) treeList.add(n.left);
                          // if (n.right != null) treeList.add(n.right);
                          if (n.left != null) treeList.add(0, n.left);
                          if (n.right != null) treeList.add(0, n.right);
                      } else {
                          // if (n.right != null) treeList.add(0, n.right);
                          // if (n.left != null) treeList.add(0, n.left);
                          if (n.right != null) treeList.add(n.right);
                          if (n.left != null) treeList.add(n.left);
                      }
                  }
                  lTor = !lTor;
                  list.add(valList);
              }
              return list;
          }
      }
    #+end_src 
*** ~Stack~ + ~LinkedList~
    #+begin_src java :classname 
      import java.util.*;

      public class Solution {
          public ArrayList<ArrayList<Integer>> Print(TreeNode pRoot) {
              ArrayList<ArrayList<Integer>> list = new ArrayList<>();
              if (pRoot == null) return list;
              Stack<TreeNode> treeStack = new Stack<>();
              boolean lTor = true;
              treeStack.push(pRoot);
              while (!treeStack.isEmpty()) {
                  int nodes = treeStack.size();
                  ArrayList<Integer> valList = new ArrayList<>();
                  LinkedList<TreeNode> nodeList = new LinkedList<>();
                  for (int i = 0; i < nodes; i++) {
                      TreeNode n = treeStack.pop();
                      valList.add(n.val);
                      nodeList.add(n);
                  }
                  while (nodeList.size() > 0) {
                      TreeNode n = nodeList.removeFirst();
                      if (lTor) {
                          if (n.left != null) treeStack.push(n.left);
                          if (n.right != null) treeStack.push(n.right);
                      } else {
                          if (n.right != null) treeStack.push(n.right);
                          if (n.left != null) treeStack.push(n.left);
                      }
                  }
                  lTor = !lTor;
                  list.add(valList);
              }
              return list;
          }
      }
    #+end_src 
*** ~Queue~ + ~LinkedList~
    #+begin_src java :classname 
      import java.util.*;

      public class Solution {
          public ArrayList<ArrayList<Integer>> Print(TreeNode pRoot) {
              ArrayList<ArrayList<Integer>> list = new ArrayList<>();
              if (pRoot == null) return list;
              Queue<TreeNode> treeQueue = new LinkedList<>();
              boolean lTor = true;
              treeQueue.offer(pRoot);
              while (!treeQueue.isEmpty()) {
                  int nodes = treeQueue.size();
                  ArrayList<Integer> valList = new ArrayList<>();
                  LinkedList<TreeNode> nodeList = new LinkedList<>();
                  for (int i = 0; i < nodes; i++) {
                      TreeNode n = treeQueue.poll();
                      valList.add(n.val);
                      if (lTor) {
                          if (n.left != null) nodeList.push(n.left);
                          if (n.right != null) nodeList.push(n.right);
                      } else {
                          if (n.right != null) nodeList.push(n.right);
                          if (n.left != null) nodeList.push(n.left);
                      }
                  }
                  treeQueue = nodeList;
                  lTor = !lTor;
                  list.add(valList);
              }
              return list;
          }
      }
    #+end_src 
*** 总结: 关于 *打印顺序* 与 *容器* 选择的思考
    - *打印顺序* 反映的 *连续性* 和 *一致性* 
      - *连续性*: 4567 or 7654, 否则破坏 *连续性*, 如5476 or 6745 -> 对容器 *无要求*
        - *先打先存*: 3先打印，则先存3的 *子节点*
        - *下层* 存序 = *本层* 打序: *从左到右* 打则先存 *左子节点* 再存 *右子节点*, 从右到左反之
      - *一致性*: 即 *下层打序* 与 *下层存序* 的关系 -> 要求 *一致性* 容器
        - 一致：下层打序 = 下层存序 -> ~Queue~
        - *反* 一致：下层打序 = *反* 下层存序 -> ~Stack~ 或 ~LinkedList~
    - *容器数量* 与 *分层*
      - *连续* -> *效果上* 可实现分层和不分层
      - *连续且一致* -> 只需 *1个* 具有 *一致性* 的容器 (~Queue~) *打存一体*, *原理上* 能实现分层和不分层
      - *连续反一致* -> 需要 *1个* 具有 *反一致性* 的 *存储* 容器 (~Stack~) + *1个打印* 容器或 *1个* 集 *一致性* 和 *反一致性* 为一体的容器 (~LinkedList~), *原理上* 仅能实现分层
    - *连续反一致* 关键代码 [[elink5][Queue Stack LinkedList]] 
      - ~Stack~ + ~Stack~
        #+begin_src java :classname 
          for (int i = 0; i < nodes; i++) {
              TreeNode n = treeStack1.pop();
              valList.add(n.val);
              if (lTor) {
                  if (n.left != null) treeStack2.push(n.left);
                  if (n.right != null) treeStack2.push(n.right);
              } else {
                  if (n.right != null) treeStack2.push(n.right);
                  if (n.left != null) treeStack2.push(n.left);
              }
          }
        #+end_src
      - ~LinkedList~
        #+begin_src java :classname 
          for (int i = 0; i < nodes; i++) {
              // TreeNode n = lTor ? treeList.removeFirst() : treeList.removeLast();
              TreeNode n = lTor ? treeList.removeLast() : treeList.removeFirst();
              valList.add(n.val);
              if (lTor) {
                  // if (n.left != null) treeList.add(n.left);
                  // if (n.right != null) treeList.add(n.right);
                  if (n.left != null) treeList.add(0, n.left);
                  if (n.right != null) treeList.add(0, n.right);
              } else {
                  // if (n.right != null) treeList.add(0, n.right);
                  // if (n.left != null) treeList.add(0, n.left);
                  if (n.right != null) treeList.add(n.right);
                  if (n.left != null) treeList.add(n.left);
              }
          }
        #+end_src 
      - ~Stack~ + ~LinkedList~
        #+begin_src java :classname 
          for (int i = 0; i < nodes; i++) {
              TreeNode n = treeStack.pop();
              valList.add(n.val);
              nodeList.add(n);
          }
          while (nodeList.size() > 0) {
              TreeNode n = nodeList.removeFirst();
              if (lTor) {
                  if (n.left != null) treeStack.push(n.left);
                  if (n.right != null) treeStack.push(n.right);
              } else {
                  if (n.right != null) treeStack.push(n.right);
                  if (n.left != null) treeStack.push(n.left);
              }
          }
        #+end_src 
      - ~Queue~ + ~LinkedList~
        #+begin_src java :classname 
          for (int i = 0; i < nodes; i++) {
              TreeNode n = treeQueue.poll();
              valList.add(n.val);
              if (lTor) {
                  if (n.left != null) nodeList.push(n.left);
                  if (n.right != null) nodeList.push(n.right);
              } else {
                  if (n.right != null) nodeList.push(n.right);
                  if (n.left != null) nodeList.push(n.left);
              }
          }
        #+end_src 
* 33 二叉搜索树的后序遍历序列 <<ilink31>>
** 递归
*** 直接  
    - 优化
      #+begin_src java :classname 
        import java.util.*;

        public class Solution {
            public boolean VerifySquenceOfBST(int[] sequence) {
                if (sequence == null || sequence.length == 0) return false;
                int len = sequence.length;
                if (len <= 2) return true;
                int i = 0;
                for (; i < len-1; i++) {
                    if (sequence[i] > sequence[len-1]) break;
                }
                int j = i;
                for (; j < len-1; j++) {
                    if (sequence[j] <= sequence[len-1]) return false;
                }
                boolean left = true, right = true;
                if (i > 0) left = VerifySquenceOfBST(Arrays.copyOfRange(sequence, 0, i));
                if (j < len-1) right = VerifySquenceOfBST(Arrays.copyOfRange(sequence, j, len-1));
                return left && right;
            }
        }
      #+end_src
      - 递归分析
        - 父子问题
          - 判断数组是不是某二叉搜索树的后序遍历结果
          - 判断该数组的 *子树部分数组* 是不是对应子树的后序遍历结果
        - *Base*: <<ilink20>>
          #+begin_src java :classname 
            if (len <= 2) return true;
            int i = 0;
            for (; i < len-1; i++) {
                if (sequence[i] > sequence[len-1]) break;
            }
            int j = i;
            for (; j < len-1; j++) {
                if (sequence[j] <= sequence[len-1]) return false;
            }
            boolean left = true, right = true;
          #+end_src
        - 父答案 = 子答案 + 子树满足 *初步合法前提*: 即左子树均 <= 根节点，右子树均 > 根节点
          - *初步合法前提*: 左子树保证 *初步合法* -> 检查右子树
            #+begin_src java :classname 
              for (; i < len-1; i++) {
                  if (sequence[i] > sequence[len-1]) break;
              }
              int j = i;
              for (; j < len-1; j++) {
                  if (sequence[j] <= sequence[len-1]) return false;
              }
            #+end_src
          - 子答案
            #+begin_src java :classname 
              boolean left = true, right = true;
              if (i > 0) left = VerifySquenceOfBST(Arrays.copyOfRange(sequence, 0, i));
              if (j < len-1) right = VerifySquenceOfBST(Arrays.copyOfRange(sequence, j, len-1));
              return left && right;
            #+end_src 
        - 复杂度可接受
          - 
          - 
    - 未优化
      #+begin_src java :classname 
        import java.util.*;
  
        public class Solution {
            public boolean VerifySquenceOfBST(int[] sequence) {
                if (sequence == null || sequence.length == 0) return false;
                int length = sequence.length;
                if (length <= 2) return true;
                int leftIndex = -1;
                for (int i = length - 2; i >= 0; i--) {
                    if (sequence[i] <= sequence[length-1]) {
                        leftIndex = i;
                        break;
                    }
                }
                int[] left = Arrays.copyOfRange(sequence, 0, leftIndex+1);
                if (left.length >= 1 && max(left) > sequence[length-1]) return false;
                int[] right = Arrays.copyOfRange(sequence, leftIndex+1, length-1);
                if (right.length >= 1 && min(right) <= sequence[length-1]) return false;
                if (left.length == 0) return VerifySquenceOfBST(right);
                if (right.length == 0) return VerifySquenceOfBST(left);
                return VerifySquenceOfBST(left) && VerifySquenceOfBST(right);
            }
  
            private int max(int[] left) {
                int max = left[0];
                for (int i = 0; i < left.length; i++) {
                    max = left[i] > max ? left[i] : max;
                }
                return max;
            }
  
            private int min(int[] right) {
                int min = right[0];
                for (int i = 0; i < right.length; i++) {
                    min = right[i] < min ? right[i] : min;
                }
                return min;
            }
        }
      #+end_src
*** 辅助递归
    #+begin_src java :classname 
      import java.util.*;

      public class Solution {
          public boolean VerifySquenceOfBST(int[] sequence) {
              if (sequence == null || sequence.length == 0) return false;
              int length = sequence.length;
              if (length <= 2) return true;
              return verifyHelper(sequence, 0, length-1);
          }

          private boolean verifyHelper(int[] sequence, int first, int last) {
              if (last <= first) return true;
              int index = -1;
              for (int i = last-1; i >= first; i--) {
                  if (sequence[i] <= sequence[last]) {
                      index = i;
                      break;
                  }
              }
              for (int i = first; i < index; i++) {
                  if (sequence[i] > sequence[last]) return false;
              }
              return verifyHelper(sequence, first, index) && verifyHelper(sequence, index+1, last-1);
          }
      }
    #+end_src 
    - 原方法受限于 *签名* 的原因递归写起来逻辑繁杂 -> 定义递归 *辅助* 方法
    - 此处右子树 *初步合法*, 需要检查左子树 -> *Base* 为
      #+begin_src java :classname 
        if (last <= first) return true;
        int index = -1;
        for (int i = last-1; i >= first; i--) {
            if (sequence[i] <= sequence[last]) {
                index = i;
                break;
            }
        }
        for (int i = first; i < index; i++) {
            if (sequence[i] > sequence[last]) return false;
        }
      #+end_src 
*** Question:                                                     :QUESTIONS:
    - [ ] 直接与辅助的复杂度分析？
    - [ ] *[[ilink20][Base]]* 思考: *Base* 一定是最小子问题吗？在该题中是什么？有点像某种前提？
** 迭代                                                               :EXTRA:
*** 利用中序与后序关系
    #+begin_src java :classname 
      import java.util.*;

      public class Solution {
          public boolean VerifySquenceOfBST(int[] sequence) {
              if (sequence == null || sequence.length == 0) return false;
              int length = sequence.length;
              if (length <= 2) return true;
              int[] inOrder = sequence.clone();
              Arrays.sort(inOrder);
              return IsPopOrder(inOrder, sequence);
          }

          public boolean IsPopOrder(int[] pushA,int[] popA) {
              if (pushA == null || popA == null || pushA.length != popA.length) return false;
              Stack<Integer> s = new Stack<>();
              int j = 0;
              for (int i = 0; i < pushA.length; i++) {
                  s.push(pushA[i]);
                  while (!s.empty() && s.peek() == popA[j]) {
                      s.pop();
                      j += 1;
                  }
              }
              return s.empty();
          }
      }
    #+end_src 
    - 有问题， *必要不充分*: 以二叉搜索树的 *层序遍历* 顺序 *入栈* -> 其 *后序遍历* 为 *出栈* 的一种，但 *出栈* 的不一定就是 *后序遍历*
    - ~Object.clone()~
    - ~Arrays.sort()~ 
*** 最大最小边界约束法                                           :UNRESOLVED:
    #+begin_src C 
      class Solution {
      public:
          bool VerifySquenceOfBST(vector<int> &sequence) {
              if (sequence.size() < 1) return false;
              else if (sequence.size() < 3) return true;
              else {
                  int idx = sequence.size() - 1;
                  stack<int> bound_min, bound_max;
                  stack<int> roots;
                  roots.push(sequence[idx--]);
                  bound_min.push(INT_MIN);
                  bound_max.push(INT_MAX);
 
                  for (; idx > -1; idx--) {
                      if (sequence[idx] > sequence[idx+1]) {
                          // 倒序遍历趋势为递增，说明是进入了某个右子树
                          if (sequence[idx] > bound_max.top())
                              // 当前元素超越了最大上限约束，这是不合法的
                              return false;
                          else {
                              // 合法，进入右子树，更新三个栈
                              bound_min.push(roots.top());
                              bound_max.push(bound_max.top());
                              roots.push(sequence[idx]);
                          }
                      }
                      else {
                          // 倒序遍历趋势为递减，说明是进入了某个左子树
                          if (sequence[idx] < bound_min.top()) {
                              // 当前元素打破了最小下限约束，说明是右子树遍历完了，跳转到兄弟左子树
                              // 当前元素为兄弟左子树的根，之前右子树节点全部出栈
                              while (sequence[idx] < bound_min.top()) {
                                  bound_min.pop();
                                  bound_max.pop();
                                  roots.pop();
                              }
                          }
                          else {} // 没有突破下限，说明是右子树不存在，直接进入左子树，不做特殊处理
                          // 进入左子树，更新三个栈
                          bound_min.push(bound_min.top());
                          bound_max.push(roots.top());
                          roots.push(sequence[idx]);
                      }
                  }
                  return true;
              }
          }
      };
    #+end_src
*** 利用排序                                                     :UNRESOLVED:
    #+begin_src C 
      class Solution {
       public:
        bool VerifySquenceOfBST(vector<int> sequence) {
          if(sequence.empty()) return false;
          int root = sequence[sequence.size()-1];
          vector<int> v = sequence;
          stable_partition(v.begin(), v.end(), [root](int x){return x<root;});
          return v == sequence;
        }
      };
    #+end_src
*** 基于递归思想                                                 :UNRESOLVED:
    #+begin_src C 
      class Solution {
       public:
        bool VerifySquenceOfBST(vector<int> sequence) {
          int size = sequence.size();
          if(0==size)return false;
 
          int i = 0;
          while(--size)
            {
              while(sequence[i++]<sequence[size]);
              while(sequence[i++]>sequence[size]);
 
              if(i<size)return false;
              i=0;
            }
          return true;
        }
      };
    #+end_src
* 34 二叉树中和为某一值的路径                                       :TOBEORG:
** 递归(回溯 前序遍历) <<ilink32>>
*** 不考虑数组长度(无辅助有返回递归函数)
    #+begin_src java :classname 
      import java.util.*;

      public class Solution {
          public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
              ArrayList<ArrayList<Integer>> paths = new ArrayList<>();
              if (root == null) return paths;
              if (root.val == target && root.left == null && root.right == null) {
                  ArrayList<Integer> path = new ArrayList<>();
                  path.add(root.val);
                  paths.add(path);
              }
              if (root.left != null) {
                  for (ArrayList<Integer> path : FindPath(root.left, target-root.val)) {
                      if (!path.isEmpty()) {
                          path.add(0, root.val);
                          paths.add(path);
                      }
                  }
              }
              if (root.right != null) {
                  for (ArrayList<Integer> path : FindPath(root.right, target-root.val)) {
                      if (!path.isEmpty()) {
                          path.add(0, root.val);
                          paths.add(path);
                      }
                  }
              }
              return paths;
          }
      }
    #+end_src 
    #+begin_src java :classname 
      import java.util.*;

      public class Solution {
          private ArrayList<ArrayList<Integer>> paths = new ArrayList<>();
          private ArrayList<Integer> path = new ArrayList<>();
          public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
              if (root == null) return paths;
              path.add(root.val);
              target -= root.val;
              if (target == 0 && root.left == null && root.right == null) paths.add(new ArrayList<Integer>(path));
              if (root.left != null) FindPath(root.left, target);
              if (root.right != null) FindPath(root.right, target);
              path.remove(path.size() - 1);
              return paths;
          }
      }
    #+end_src 
*** 考虑数组长度(借助辅助无返回递归函数)
    #+begin_src java :classname 
      import java.util.*;

      public class Solution {
          public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
              ArrayList<ArrayList<Integer>> paths = new ArrayList<>();
              ArrayList<Integer> path = new ArrayList<>();
              // Comparator<ArrayList<Integer>> pathComparator = (ArrayList<Integer> path1, ArrayList<Integer> path2) -> {
              //     // return Integer.compare(path2.size(), path1.size());
              //     return path1.size() < path2.size() ? 1 : -1;
              // };
              if (root != null) FindPath(root, target, paths, path);
              // Collections.sort(paths, pathComparator);
              Collections.sort(paths, new Comparator<ArrayList<Integer>>() {
                      @Override
                      public int compare(ArrayList<Integer> path1, ArrayList<Integer> path2) {
                          return path1.size() < path2.size() ? 1 : -1;
                      }
                  });
              return paths;
          }

          private void FindPath(TreeNode root, int target, ArrayList<ArrayList<Integer>> paths, ArrayList<Integer> path) {
              path.add(root.val);
              target -= root.val;
              if (target == 0 && root.left == null && root.right == null) {
                  paths.add(new ArrayList<Integer>(path));
              }
              if (root.left != null) FindPath(root.left, target, paths, path);
              if (root.right != null) FindPath(root.right, target, paths, path);
              path.remove(path.size() - 1);
          }
      }
    #+end_src 
*** Question:                                                     :QUESTIONS:
    - [ ] 关于递归，结合 [[ilink21][offer36]] [[ilink22][offer12]] [[ilink23][offer13]] [[file:~/csnds/Dropbox/orglife/61b_projs.org::<<elink3>>][61b作业]] 思考 <<elink6>>
      - [ ] 有无返回
      - [ ] 有无辅助方法
      - [ ] 有无成员变量辅助记录状态
      - [ ] 递归与回溯关系
** 迭代(后序遍历)                                                :UNRESOLVED:
   #+begin_src C 
     /*
       非递归法：后序遍历
       1.进栈时候，把值同时压入路径的向量数组，修正路径的和
       2.出栈时候，先判断和是否相等，且该节点是否是叶节点，
       判断完成后保持和栈一致，抛出路径，修改路径的和
       3.向量数组和栈的操作要保持一致
     ,*/
     class Solution {
      public:
       vector<vector<int> > FindPath(TreeNode* root, int expectNumber) {
         stack<TreeNode*> s;
         vector<int> v;
         vector<vector<int> > res;
         while (root || !s.empty()){
           while (root){
             s.push(root); v.push_back(root->val); expectNumber -= root->val;
             //能左就左，否则向右
             root = root->left ? root->left : root->right;
           }
           root = s.top();
           if (expectNumber == 0 && root->left == NULL && root->right == NULL)
             res.push_back(v);
           s.pop(); v.pop_back(); expectNumber += root->val;
           //右子数没遍历就遍历，如果遍历就强迫出栈
           if (!s.empty() && s.top()->left == root)
             root = s.top()->right;
           else
             root = NULL;//强迫出栈
         }
         return res;
       }
     };
   #+end_src
* 35 复杂链表的复制
** 辅助空间(~HashMap~)
   #+begin_src java :classname 
     import java.util.*;

     public class Solution {
         public RandomListNode Clone(RandomListNode pHead) {
             if (pHead == null) return null;
             HashMap<RandomListNode, RandomListNode> map = new HashMap<>();
             RandomListNode cHead = new RandomListNode(pHead.label);
             RandomListNode p = pHead, c = cHead;
             map.put(p, c);
             while (p.next != null) {
                 c.next = new RandomListNode(p.next.label);
                 c = c.next;
                 p = p.next;
                 map.put(p, c);
             }

             // RandomListNode cHead = new RandomListNode(0);
             // RandomListNode p = pHead, c = cHead;
             // while (p != null) {
             //     c.next = new RandomListNode(p.label);
             //     c = c.next;
             //     map.put(p, c);
             //     p = p.next;
             // }
             // cHead = cHead.next;

             p = pHead;
             while (p != null) {
                 map.get(p).random = map.get(p.random);
                 p = p.next;
             }
             return cHead;
         }
     }
   #+end_src 
   - 分2步 *遍历*: 第1次遍历拷贝 *顺序* 并记录 *原与拷贝节点对*--> 第2次遍历根据 *原链表随机* 以及 *节点对* 拷贝 *随机*
   - 第1次
     #+begin_src java :classname 
       HashMap<RandomListNode, RandomListNode> map = new HashMap<>();
       RandomListNode cHead = new RandomListNode(pHead.label);
       RandomListNode p = pHead, c = cHead;
       map.put(p, c);
       while (p.next != null) {
           c.next = new RandomListNode(p.next.label);
           c = c.next;
           p = p.next;
           map.put(p, c);
       }

       // RandomListNode cHead = new RandomListNode(0);
       // RandomListNode p = pHead, c = cHead;
       // while (p != null) {
       //     c.next = new RandomListNode(p.label);
       //     map.put(p, c.next);
       //     c = c.next;
       //     p = p.next;
       // }
       // cHead = cHead.next;
     #+end_src
     - ~HashMap<RandomListNode, RandomListNode> map = new HashMap<>()~
     - 无哨兵: 先 ~map.put(p, c)~ 一次 + 判断 ~while (p.next != null)~
     - 有哨兵: 判断 ~while (p != null)~ + ~map.put(p, c.next)~ 
   - 第2次
     #+begin_src java :classname 
       p = pHead;
       while (p != null) {
           map.get(p).random = map.get(p.random);
           p = p.next;
       }
     #+end_src
     - 拷贝随机 ~map.get(p).random = map.get(p.random)~ 
   - 极端情况: ~if (pHead == null) return null~
   - 复杂度
     - $O(n)$
     - $O(n)$
** 无辅助空间
   #+begin_src java :classname 
     import java.util.*;

     public class Solution {
         public RandomListNode Clone(RandomListNode pHead) {
             if (pHead == null) return null;

             RandomListNode p = pHead;
             RandomListNode cp;
             while (p != null) {
                 RandomListNode pnext = p.next;
                 cp = new RandomListNode(p.label);
                 cp.next = pnext;
                 p.next = cp;
                 p = pnext;
             }

             p = pHead;
             while (p != null) {
                 cp = p.next;
                 if (p.random != null) cp.random = p.random.next;
                 p = cp.next;
             }

             cp = pHead.next;
             while (cp.next != null) {
                 cp.next = cp.next.next;
                 cp = cp.next;
             }
             RandomListNode cHead = pHead.next;
             pHead.next = null;
             return cHead;

             // RandomListNode cHead = pHead.next;
             // p = pHead;
             // while (p != null) {
             //     cp = p.next;
             //     p.next = cp.next;
             //     if (cp.next != null) cp.next = cp.next.next;
             //     p = p.next;
             // }
             // return cHead;
         }
     }
   #+end_src 
   - 分3步: 向后拷贝插入顺序 --> 拷贝原随机 --> 取出拷贝节点重建拷贝链表
   - 复杂度
     - $O(n)$
     - $O(1)$
** 有向图法                                                      :UNRESOLVED:
   #+begin_src C 
     class Solution {
       map<RandomListNode*, RandomListNode*> mp;
       set<RandomListNode*> vis;
       void dfs1(RandomListNode* u){
         if(u && mp.find(u) == mp.end()) {
           mp[u] = new RandomListNode(u -> label);
           dfs1(u -> next);
           dfs1(u -> random);
         }
       }
       void dfs2(RandomListNode* u){
         if(u && vis.find(u) == vis.end()){
           if(u -> next) mp[u] -> next = mp[u -> next];
           if(u -> random) mp[u] -> random = mp[u -> random];
           vis.insert(u);
           dfs2(u -> next);
           dfs2(u -> random);
         }
       }
      public:
       RandomListNode* Clone(RandomListNode* pHead){
         if(!pHead) return NULL;
         mp.clear();
         vis.clear();
         dfs1(pHead);
         dfs2(pHead);
         return mp[pHead];
       }
     };
   #+end_src
* 36 二叉搜索树与双向链表                                           :TOBEORG:
** 递归 <<ilink21>>
*** 循环双向链表
    #+begin_src java :classname 
      import java.util.*;

      public class Solution {
          public TreeNode Convert(TreeNode pRootOfTree) {
              if (pRootOfTree == null) return null;
              TreeNode head = Helper(pRootOfTree);
              head.left.right = null;
              head.left = null;
              return head;
          }
          private TreeNode Helper(TreeNode pRootOfTree) {
              if (pRootOfTree == null) return null;
              if (pRootOfTree.left == null && pRootOfTree.right == null) {
                  pRootOfTree.left = pRootOfTree;
                  pRootOfTree.right = pRootOfTree;
                  return pRootOfTree;
              }
              TreeNode lNode = Helper(pRootOfTree.left);
              TreeNode rNode = Helper(pRootOfTree.right);
              if (lNode == null) {
                  pRootOfTree.right = rNode;
                  pRootOfTree.left = rNode.left;
                  rNode.left.right = pRootOfTree;
                  rNode.left = pRootOfTree;
                  return pRootOfTree;
              } else if (rNode == null) {
                  lNode.left.right = pRootOfTree;
                  pRootOfTree.left = lNode.left;
                  pRootOfTree.right = lNode;
                  lNode.left = pRootOfTree;
                  return lNode;
              } else {
                  lNode.left.right = pRootOfTree;
                  pRootOfTree.left = lNode.left;
                  rNode.left.right = lNode;
                  lNode.left = rNode.left;
                  pRootOfTree.right = rNode;
                  rNode.left = pRootOfTree;
                  return lNode;
              }
          }
      }
    #+end_src 
*** 非循环双向链表(*成员变量* 记录)
    - 无辅助带返回值
      #+begin_src java :classname 
        import java.util.*;

        public class Solution {
            // private static TreeNode pre = null;
            private TreeNode pre = null;
            public TreeNode Convert(TreeNode pRootOfTree) {
                if (pRootOfTree == null) return null;
                if (pRootOfTree.left == null && pRootOfTree.right == null) {
                    pre = pRootOfTree;
                    return pRootOfTree;
                }
                TreeNode lNode = Convert(pRootOfTree.left);
                if (lNode != null) {
                    pre.right = pRootOfTree;
                    pRootOfTree.left = pre;
                }
                pre = pRootOfTree;
                TreeNode rNode = Convert(pRootOfTree.right);
                if (rNode != null) {
                    pRootOfTree.right = rNode;
                    rNode.left = pRootOfTree;
                }
                lNode = lNode != null ? lNode : pRootOfTree;
                return lNode;
            }
        }
      #+end_src
    - 辅助无返回值
      #+begin_src java :classname 
        import java.util.*;

        public class Solution {
            // private static TreeNode pre = null;
            // private static TreeNode Head = null;
            private TreeNode pre = null;
            private TreeNode Head = null;
            public TreeNode Convert(TreeNode pRootOfTree) {
                Helper(pRootOfTree);
                return Head;
            }

            private void Helper(TreeNode pRootOfTree) {
                if (pRootOfTree == null) return;
                Helper(pRootOfTree.left);
                if (pre == null) {
                    pre = pRootOfTree;
                    Head = pRootOfTree;
                } else {
                    pre.right = pRootOfTree;
                    pRootOfTree.left = pre;
                    pre = pRootOfTree;
                }
                Helper(pRootOfTree.right);
            }
        }
      #+end_src
*** Question:                                                     :QUESTIONS:
    - [ ] 为何上面使用 *成员变量* 记录时有的可以声明为 ~static~ 有的不行？
** 非递归                                                        :UNRESOLVED:
   #+begin_src java :classname 
     import java.util.*;

     public class Solution {
         public TreeNode Convert(TreeNode root) {
             if(root==null)
                 return null;
             Stack<TreeNode> stack = new Stack<TreeNode>();
             TreeNode p = root;
             TreeNode pre = null;// 用于保存中序遍历序列的上一节点
             boolean isFirst = true;
             while(p!=null||!stack.isEmpty()){
                 while(p!=null){
                     stack.push(p);
                     p = p.left;
                 }
                 p = stack.pop();
                 if(isFirst){
                     root = p;// 将中序遍历序列中的第一个节点记为root
                     pre = root;
                     isFirst = false;
                 }else{
                     pre.right = p;
                     p.left = pre;
                     pre = p;
                 }      
                 p = p.right;
             }
             return root;
         }

     }
   #+end_src
*** Question:                                                     :QUESTIONS:
    - [ ] 非递归中序遍历?
* 37 序列化二叉树                                                   :TOBEORG:
** 递归(前序遍历)
   - 使用成员变量(无辅助有返回值)
     #+begin_src java :classname 
       import java.util.*;
  
       public class Solution {
           private int index = -1;
           String Serialize(TreeNode root) {
               StringBuilder Ser = new StringBuilder();
               if (root == null) {
                   Ser.append("#,");
                   return Ser.toString();
               }
               // Ser.append(String.valueOf(root.val));
               // Integer.toString(root.val); Integer(root.val).toString();
               Ser.append(root.val + ",");
               Ser.append(Serialize(root.left));
               Ser.append(Serialize(root.right));
               return Ser.toString();
           }
           TreeNode Deserialize(String str) {
               index += 1;
               String[] sstr = str.split(",");
               TreeNode node = null;
               if (!sstr[index].equals("#")) {
                   node = new TreeNode(Integer.valueOf(sstr[index]));
                   node.left = Deserialize(str);
                   node.right = Deserialize(str);
               }
               return node;
           }
       }
     #+end_src
   - 不使用成员变量(有辅助有返回值 未调通)
     #+begin_src java :classname 
       import java.util.*;
  
       public class Solution {
           String Serialize(TreeNode root) {
               StringBuilder Ser = new StringBuilder();
               if (root == null) {
                   Ser.append("#,");
                   return Ser.toString();
               }
               // Ser.append(String.valueOf(root.val));
               // Integer.toString(root.val); Integer(root.val).toString();
               Ser.append(root.val + ",");
               Ser.append(Serialize(root.left));
               Ser.append(Serialize(root.right));
               return Ser.toString();
           }
           TreeNode Deserialize(String str) {
               return Helper(str, 0);
           }
           TreeNode Helper(String str, int index) {
               String[] sstr = str.split(",");
               TreeNode node = null;
               if (!sstr[index].equals("#")) {
                   node = new TreeNode(Integer.valueOf(sstr[index]));
                   node.left = Helper(str, index+1);
                   node.right = Helper(str, index+2);
               }
               return node;
           }
       }
     #+end_src
*** Question:                                                     :QUESTIONS:
    - [ ] 对 ~Deserialize~ 的理解
    - [ ] 不使用成员变量调通？联系 [[elink6][34]] 思考
** 非递归(层序遍历)
     #+begin_src java :classname 
       import java.util.*;

       public class Solution {
           String Serialize(TreeNode root) {
               StringBuilder Ser = new StringBuilder();
               Queue<TreeNode> queue = new LinkedList<>();
               if (root != null) queue.offer(root);
               while (!queue.isEmpty()) {
                   TreeNode node = queue.poll();
                   if (node == null) Ser.append("#,");
                   else {
                       Ser.append(node.val+",");
                       queue.offer(node.left);
                       queue.offer(node.right);
                   }
               }
               if (Ser.length() != 0) Ser.deleteCharAt(Ser.length()-1);
               return Ser.toString();
           }
           TreeNode Deserialize(String str) {
               if (str == null || str.length() == 0) return null;
               String[] sstr = str.split(",");
               TreeNode[] nodes = new TreeNode[sstr.length];
               for (int i = 0; i < sstr.length; i++) {
                   if (!sstr[i].equals("#")) nodes[i] = new TreeNode(Integer.valueOf(sstr[i]));
               }
               for (int i = 0, j = 1; j < sstr.length; i++) {
                   if (nodes[i] != null) {
                       nodes[i].left = nodes[j++];
                       nodes[i].right = nodes[j++];
                   }
               }
               return nodes[0];
           }
       }
     #+end_src
** Question:                                                      :QUESTIONS:
   - [ ] 前后中层遍历的迭代和递归写法？用后序和中序实现？
* 38 字符串的排列                                                   :TOBEORG:
** 递归(回溯) <<ilink33>>
   #+begin_src java :classname 
     import java.util.*;

     public class Solution {
         private ArrayList<String> list = new ArrayList<>();
         // private HashSet<String> set = new HashSet<>();
         public ArrayList<String> Permutation(String str) {
             Helper(str.toCharArray(), 0);
             // ArrayList<String> list = new ArrayList<>(set);
             Collections.sort(list);
             return list;
         }

         private void Helper(char[] cstr, int index) {
             if (cstr == null || cstr.length == 0) return;
             if (index == cstr.length - 1) {
                 String str = new String(cstr); //or String str = String.valueOf(cstr);
                 if (!list.contains(str)) list.add(str);
                 // set.add(str);
                 return;
             } else {
                 for (int i = index; i < cstr.length; i++) {
                     swap(cstr, i, index);
                     Helper(cstr, index+1);
                     swap(cstr, i, index);
                 }
             }
         }

         private void swap(char[] cstr, int i, int j) {
             char temp = cstr[i];
             cstr[i] = cstr[j];
             cstr[j] = temp;
         }
     }
   #+end_src 
*** Question:                                                     :QUESTIONS:
    - [ ] 递归和回溯?
** 迭代(字典生成算法)                                            :UNRESOLVED:
   #+begin_src java :classname 
     import java.util.*;

     public class Solution {

         public ArrayList<String> Permutation(String str) {
            ArrayList<String> res = new ArrayList<>();
 
             if (str != null && str.length() > 0) {
                 char[] seq = str.toCharArray();
                 Arrays.sort(seq); //排列
                 res.add(String.valueOf(seq)); //先输出一个解
 
                 int len = seq.length;
                 while (true) {
                     int p = len - 1, q;
                     //从后向前找一个seq[p - 1] < seq[p]
                     while (p >= 1 && seq[p - 1] >= seq[p]) --p;
                     if (p == 0) break; //已经是“最小”的排列，退出
                     //从p向后找最后一个比seq[p]大的数
                     q = p; --p;
                     while (q < len && seq[q] > seq[p]) q++;
                     --q;
                     //交换这两个位置上的值
                     swap(seq, q, p);
                     //将p之后的序列倒序排列
                     reverse(seq, p + 1);
                     res.add(String.valueOf(seq));
                 }
             }
 
             return res;
         }
     
         public static void reverse(char[] seq, int start) {
             int len;
             if(seq == null || (len = seq.length) <= start)
                 return;
             for (int i = 0; i < ((len - start) >> 1); i++) {
                 int p = start + i, q = len - 1 - i;
                 if (p != q)
                     swap(seq, p, q);
             }
         }
     
         public static void swap(char[] cs, int i, int j) {
             char temp = cs[i];
             cs[i] = cs[j];
             cs[j] = temp;
         }
     }
   #+end_src 

** 本体扩展                                                :UNRESOLVED:EXTRA:
   可以回忆联系下61a里类似的内容
** 相关题目                                                :UNRESOLVED:EXTRA:
* 39 数组中出现次数超过一半的数字                                   :TOBEORG:
** 利用快排的 ~Partition~ (改变数组元素)
   #+begin_src java :classname 
     public class Solution {
         public int MoreThanHalfNum_Solution(int[] array) {
             if (array == null || array.length <= 0) return 0;
             int mid = array.length >> 1;
             // Helper(array, mid, 0, array.length-1);
             // int result = array[mid];
             int start = 0, end = array.length - 1;
             int result = Partition(array, start, end);
             while (result != mid) {
                 if (result > mid) end = result - 1;
                 if (result < mid) start = result + 1;
                 result = Partition(array, start, end);
             }
             result = array[result];
             return Valid(result, array) ? result : 0;
         }

         private void Helper(int[] array, int mid, int start, int end) {
             int index = Partition(array, start, end);
             if (index == mid) return;
             if (index < mid) start = index + 1;
             if (index > mid) end = index - 1;
             Helper(array, mid, start, end);
         }

         private int Partition(int[] array, int start, int end) {
             // if (array ==  null || array.length <= 0 || start < 0 || end >= array.length || start > end) throw new E;
             // int pivot = random(start, end);
             // Swap(array, pivot, end);
             Swap(array, start, end);
             int small = start - 1;
             for (int index = start; index < end; index++) {
                 if (array[index] < array[end]) {
                     small += 1;
                     if (small != index) Swap(array, small, index);
                 }
             }
             small += 1;
             Swap(array, small, end);
             return small;
         }

         private void Swap(int[] array, int i, int j) {
             int temp = array[i];
             array[i] = array[j];
             array[j] = temp;
         }

         private boolean Valid(int result, int[] array) {
             int num = 0;
             for (int i = 0; i < array.length; i++) {
                 if (result == array[i]) num += 1;
             }
             return num > (array.length >> 1);
         }
     }
   #+end_src 
*** Question:                                                     :QUESTIONS:
    - [ ] 对比学习以下以 *数组* 为载体和以[[file:~/csnds/Dropbox/orglife/61b_labs.org::<<elink7>>][ *队列* ]]为载体的快排实现 <<ilink24>>
      #+begin_src java :classname 
        public static void QuickSort(int[] array, int start, int end) {
            if (start == end) return;
            int index = Partition(array, start, end);
            if (index > start) QuickSort(array, start, index-1);
            if (index < end) QuickSort(array, index+1, end);
        }
      #+end_src
      - 递归终止 ~start == end~ 的理解
      - 以 *数组* 为载体的非递归实现?
      - ~Generic[] array~ 的快排实现?
** 利用数组特点(不改变数组元素)
   #+begin_src java :classname 
     public class Solution {
         public int MoreThanHalfNum_Solution(int[] array) {
             if (array == null || array.length <= 0) return 0;
             int result = array[0], times = 1;
             for (int i = 1; i < array.length; i++) {
                 if (times == 0) {
                     result = array[i];
                     times = 1;
                 } else if (result == array[i]) {
                     times += 1;
                 } else {
                     times -= 1;
                 }
             }
             return Valid(result, array) ? result : 0;
         }
         private boolean Valid(int result, int[] array) {
             int num = 0;
             for (int i = 0; i < array.length; i++) {
                 if (result == array[i]) num += 1;
             }
             return num > (array.length >> 1);
         }
     }
   #+end_src 
*** Question:                                                     :QUESTIONS:
    - [ ] 进一步理解以上逻辑
    - [ ] 与利用 ~Partition~ 对比， *无有效值* 情况下两者返回值的特点?
* 40 最小的k个数                                                    :TOBEORG:
** 利用快排的 ~Partition~ (改变数组元素)
   #+begin_src java :classname 
     import java.util.ArrayList;

     public class Solution {
         public ArrayList<Integer> GetLeastNumbers_Solution(int[] input, int k) {
             ArrayList<Integer> list = new ArrayList<>();
             if (input == null || input.length < k || k <= 0) return list;
             int start = 0, end = input.length - 1;
             int result = Partition(input, start, end);
             while (result != k-1) {
                 if (result > k-1) end = result - 1;
                 if (result < k-1) start = result + 1;
                 result = Partition(input, start, end);
             }
             for (int i = 0; i <= k-1; i++) {
                 list.add(input[i]);
             }
             return list;
         }

         private int Partition(int[] array, int start, int end) {
             // if (array ==  null || array.length <= 0 || start < 0 || end >= array.length || start > end) throw new E;
             // int pivot = random(start, end);
             // Swap(array, pivot, end);
             Swap(array, start, end);
             int small = start - 1;
             for (int index = start; index < end; index++) {
                 if (array[index] < array[end]) {
                     small += 1;
                     if (small != index) Swap(array, small, index);
                 }
             }
             small += 1;
             Swap(array, small, end);
             return small;
         }

         private void Swap(int[] array, int i, int j) {
             int temp = array[i];
             array[i] = array[j];
             array[j] = temp;
         }
     }
   #+end_src 
** 利用数据容器存储
   #+begin_src java :classname 
     import java.util.*;

     public class Solution {
         public ArrayList<Integer> GetLeastNumbers_Solution(int[] input, int k) {
             ArrayList<Integer> list = new ArrayList<>();
             if (input == null || input.length < k || k <= 0) return list;
             PriorityQueue<Integer> pq = new PriorityQueue<>(k, Collections.reverseOrder());
        
             for (int i = 0; i < input.length; i++) {
                 if (pq.size() < k) pq.add(input[i]);
                 else {
                     int max = pq.peek();
                     if (max > input[i]) {
                         pq.poll();
                         pq.add(input[i]);
                     }
                 }
             }

             return new ArrayList(pq);
         }
     }
   #+end_src 
* 41 数据流中的中位数                                               :TOBEORG:
  #+begin_src java :classname 
    import java.util.*;

    public class Solution {
        PriorityQueue<Integer> min = new PriorityQueue<>();
        PriorityQueue<Integer> max = new PriorityQueue<>(1, Collections.reverseOrder());
        public void Insert(Integer num) {
            if (((min.size()+max.size()) & 1) == 0) {
                if (max.size() > 0 && num < max.peek()) {
                    max.add(num);
                    num = max.poll();
                }
                min.add(num);
            } else {
                if (min.size() > 0 && num > min.peek()) {
                    min.add(num);
                    num = min.poll();
                }
                max.add(num);
           
            }
        }

        public Double GetMedian() {
            int size = min.size() + max.size();
            Double midian = 0.0;
            if (size != 0) {
                // if ((size & 1) == 1) midian = Double.valueOf(min.peek());
                if ((size & 1) == 1) midian = new Double(min.peek());
                else midian = (min.peek() + max.peek()) / 2.0;
            }
            return midian;
        }
    }
  #+end_src 
* 42 连续子数组的最大和                                             :TOBEORG:
** 数组规律
   #+begin_src java :classname 
     public class Solution {
         public int FindGreatestSumOfSubArray(int[] array) {
             int maxSum = Integer.MIN_VALUE, sum = 0;
             if (array == null || array.length <= 0) return maxSum;
             for (int i = 0; i < array.length; i++) {
                 sum += array[i];
                 if (maxSum < sum) maxSum = sum;
                 if (sum < 0) {
                     sum = 0;
                 }
             }
             return maxSum;
         }
     }
   #+end_src 
** 动态规划
   #+begin_src java :classname 
     public class Solution {
         public int FindGreatestSumOfSubArray(int[] array) {
             int maxSum = Integer.MIN_VALUE, sum = 0;
             if (array == null || array.length <= 0) return maxSum;
             for (int i = 0; i < array.length; i++) {
                 sum = sum + array[i] > array[i] ? sum + array[i] : array[i];
                 maxSum = sum > maxSum ? sum : maxSum;
             }
             return maxSum;
         }
     }
   #+end_src 
* 43 1~n整数中1出现的次数                                        :UNRESOLVED:
  #+begin_src java :classname 
    public class Solution {
        public int NumberOf1Between1AndN_Solution(int n) {
    
        }
    }
  #+end_src 
* 44 数字序列中某一位的数字                                         :TOBEORG:
  #+begin_src java :classname 
    import java.util.*;

    class Solution {
        public int findNthDigit(int n) {
            if (n <= 0) return 0;
            if (n <= 9) return n;
            n -= 10;
            int i = 1;

            while (true) {
                // int j = 9 * (int) Math.pow(10,i) * (i+1);
                int j = (int) (9 * Math.pow(10,i) * (i+1));
                if (n < j) break;
                i += 1;
                n -= j;
            }
            // int num = n / (i+1) + (int) Math.pow(10,i);
            int num = (int) (n/(i+1) + Math.pow(10,i));
            return String.valueOf(num).charAt(n%(i+1)) - '0';
        }
    }
  #+end_src 
** Question:                                                      :QUESTIONS:
   - [ ] 关于 ~(int)~ 强制类型转换的问题
* 45 把数组排成最小的数                                             :TOBEORG:
  - 用 ~String[]~ 和 ~StringBuffer~ 
    #+begin_src java :classname 
      import java.util.*;
  
      class Solution {
          public String minNumber(int[] nums) {
              if (nums == null || nums.length <= 0) return null;
              String[] str = new String[nums.length];
              for (int i = 0; i < nums.length; i++) {
                  str[i] = Integer.toString(nums[i]);
                  // str[i] = String.valueOf(nums[i]);
              }
  
              // Comparator<String> strComparator = (String s1, String s2) -> {
              //     return (s1+s2).compareTo(s2+s1);
              // };
              // Arrays.sort(str, strComparator);
  
              Arrays.sort(str, new Comparator<String>() {
                      @Override
                      public int compare(String s1, String s2) {
                          return (s1+s2).compareTo(s2+s1);
                      }
                  });
  
              StringBuffer sstr = new StringBuffer();
              for (int i = 0; i< str.length; i++) {
                  sstr.append(str[i]);
              }
              return sstr.toString();
          }
      }
    #+end_src
  - 用 ~List~ (耗时更长)
    #+begin_src java :classname 
      class Solution {
          public String minNumber(int[] nums) {
              List<String> list = new ArrayList<>();
              for (int num : nums) {
                  list.add(String.valueOf(num));
              }
              list.sort((o1, o2) -> (o1 + o2).compareTo(o2 + o1));
              return String.join("", list);
          }
      }
    #+end_src
  - 会错题意(以为以 ~char~ 为最小单位)
    #+begin_src java :classname 
      import java.util.*;
  
      class Solution {
          public String minNumber(int[] nums) {
              if (nums == null || nums.length <= 0) return null;
              StringBuffer str = new StringBuffer();
              for (int i = 0; i < nums.length; i++) {
                  str.append(nums[i]);
              }
              char[] ch = (new String(str)).toCharArray();
              Arrays.sort(ch);
              int count = 0;
              for (int i = 0; i < ch.length; i++) {
                  if (ch[i] != '0') break;
                  count += 1;
              }
              int len = str.length();
              if (count < ch.length) str.append(ch, count, 1);
              str.append(ch, 0, count);
              if (count < ch.length - 1) str.append(ch, count+1, ch.length-count-1);
              str.delete(0, len);
              return str.toString();
          }
      }
    #+end_src
** Question:                                                      :QUESTIONS:
   - [ ] 为什么用 ~list~ 会慢？
   - [ ] 数学证明有效性？
* 46 把数字翻译成字符串 <<ilink29>>                                 :TOBEORG:
** 递归(回溯) <<ilink34>>
   #+begin_src java :classname 
     class Solution {
         public int translateNum(int num) {
             String str = String.valueOf(num);
             return Helper(str, 0);
         }

         private int Helper(String str, int pos) {
             int len = str.length();

             if (pos >= len-1) return 1;
             String substr = str.substring(pos, pos+2);
             int subint = Integer.parseInt(substr);
             if (str.charAt(pos) == '0' || subint > 25) return Helper(str, pos+1);
             return Helper(str, pos+1) + Helper(str, pos+2);
         }
     }
   #+end_src 
*** Question:                                                     :QUESTIONS:
    - [ ] 重复子问题不会影响结果吗(联系非波拉起递归)?如何避免重复子问题？
** 划分型DP
   #+begin_src java :classname 
     class Solution {
         public int translateNum(int num) {
             String str = String.valueOf(num);
             int len = str.length();
             int[] dp = new int[11];
             dp[0] = 1;
             dp[1] = 1;
             for (int i = 1; i < len; i++) {
                 String substr = str.substring(i-1, i+1);
                 int subint = Integer.parseInt(substr);
                 if (str.charAt(i-1) == '0' || subint > 25) dp[i+1] = dp[i];
                 else dp[i+1] = dp[i] + dp[i-1];
             }
             return dp[len];
         }
     }
   #+end_src 
*** Question:                                                     :QUESTIONS: <<ilink27>>
    - [ ] dp问题仿照递归问题的分析模式: 问题建模(划分型) 依赖定式 初始边界 开始与结束等
    - [ ] 书上的"从最小子问题自下而上解决问题"思路?与本题dp关系?
    - [ ] 递归 回溯 dp 迭代 关系?自上而下 自下而上 自大而小 自小而大?
** 书上思路(迭代)                                                :UNRESOLVED:
* 47 礼物的最大价值                                                 :TOBEORG:
** DP
   #+begin_src java :classname 
     class Solution {
         public int maxValue(int[][] grid) {
             if (grid == null || grid.length <= 0 || grid[0].length <= 0) return 0;
             int rows = grid.length;
             int cols = grid[0].length;
             for (int row = 1; row < rows; row++) {
                 grid[row][0] += grid[row-1][0];
             }
             for (int col = 1; col < cols; col++) {
                 grid[0][col] += grid[0][col-1];
             }

             for (int row = 1; row < rows; row++) {
                 for (int col = 1; col < cols; col++) {
                     grid[row][col] += Math.max(grid[row-1][col], grid[row][col-1]);
                 }
             }
             return grid[rows-1][cols-1];
         }
     }
   #+end_src 
* 48 最长不含重复字符的子字符串                                     :TOBEORG:
** 借助HashMap
*** 原思路
    #+begin_src java :classname 
       class Solution {
          public int lengthOfLongestSubstring(String s) {
              if (s == null || s.length() <= 0) return 0;
              HashMap<Character, Integer> map = new HashMap<>();
              int result = 0, len = s.length();
              for (int i = 0; i < len; i++) {
                  if (len - i <= result) break;
                  for (int j = i; j < len; j++) {
                      char c = s.charAt(j);
                      if (!map.containsKey(c)) map.put(c, j);
                      else {
                          i = map.get(c);
                          result = result < map.size() ? map.size() : result;
                          map.clear();
                          break;
                      }
                  }
              }
              result = result < map.size() ? map.size() : result;
              return result;
          }
      }
    #+end_src 
*** 滑动窗口(双指针) 
    #+begin_src java :classname 
      class Solution {
          public int lengthOfLongestSubstring(String s) {
              if (s == null || s.length() <= 0) return 0;
              HashMap<Character, Integer> map = new HashMap<>();
              int result = 0, head = 0, len = s.length();
              for (int tail = 0; tail < len; tail++) {
                  char c = s.charAt(tail);
                  if (map.containsKey(c) && map.get(c) >= head) {
                      if (tail - head > result) result = tail - head;
                      head = map.get(c) + 1;
                  }
                  map.put(c, tail);
              }
              if (result < len - head) result = len - head;
              return result;
          }
      }
    #+end_src 
** DP(迭代)
   #+begin_src java :classname 
     class Solution {
         public int lengthOfLongestSubstring(String s) {
             if (s == null || s.length() <= 0) return 0;
             int curLen = 0, maxLen = 0;
             int[] pos = new int[95];
             for (int i = 0; i < 95; i++) {
                 pos[i] = -1;
             }

             for (int i = 0; i < s.length(); i++) {
                 int offSet = s.charAt(i) - ' ';
                 int prevIndex = pos[offSet];
                 if (prevIndex < 0 || i - prevIndex > curLen) curLen += 1;
                 else {
                     if (maxLen < curLen) maxLen = curLen;
                     curLen = i - prevIndex;
                 }
                 pos[offSet] = i;
             }
             return maxLen > curLen ? maxLen : curLen;
         }
     }
   #+end_src 
** 递归                                                          :UNRESOLVED:
* 49 丑数                                                           :TOBEORG:
** 递归                                                          :UNRESOLVED:
   #+begin_src java :classname 
     class Solution {
         public int nthUglyNumber(int n) {
             if (n <= 3) return n;
             int pre = nthUglyNumber(n-1);
             if (isUgly(pre+1)) return pre + 1;
             else {

             }
         }

         private boolean isUgly(int n) {
             while (n % 2 == 0) {
                 n /= 2;
             }
             while (n % 3 == 0) {
                 n /= 3;
             }
             while (n % 5 == 0) {
                 n /= 5;
             }
             return n == 1;
         }
     }
   #+end_src 
** DP(利用数组保存)
  #+begin_src java :classname 
    class Solution {
        public int nthUglyNumber(int n) {
            if (n <= 0) return 0;
            int[] uglyNums = new int[n];
            int p2 = 0, p3 = 0, p5 = 0;
            uglyNums[0] = 1;
            for (int i = 1; i < n; i++) {
                uglyNums[i] = min(uglyNums[p2]*2, uglyNums[p3]*3, uglyNums[p5]*5);
                // while (uglyNums[p2]*2 <= uglyNums[i]) p2 += 1;
                // while (uglyNums[p3]*3 <= uglyNums[i]) p3 += 1;
                // while (uglyNums[p5]*5 <= uglyNums[i]) p5 += 1;
                if (uglyNums[p2]*2 == uglyNums[i]) p2 += 1;
                if (uglyNums[p3]*3 == uglyNums[i]) p3 += 1;
                if (uglyNums[p5]*5 == uglyNums[i]) p5 += 1;
            }
            return uglyNums[n-1];
        }

        private int min(int n1, int n2, int n3) {
            int n = n1 > n2 ? n2 : n1;
            return n > n3 ? n3 : n;
        }
    }
  #+end_src 
* 50 第一个只出现一次的字符                                         :TOBEORG:
** 用 ~HashMap~ 
   #+begin_src java :classname 
     class Solution {
         public char firstUniqChar(String s) {
             if (s == null || s.length() <= 0) return ' ';
             HashMap<Character, Integer> map = new HashMap<>();
             int len = s.length();
             for (int i = 0; i < len; i++) {
                 char c = s.charAt(i);
                 if (!map.containsKey(c)) map.put(c, 1);
                 else map.put(c, map.get(c)+1);
             }
             for (int i = 0; i < len; i++) {
                 char c = s.charAt(i);
                 if (map.get(c) == 1) return c;
             }
             return ' ';
         }
     }
   #+end_src 
** 用数组模拟 ~HashMap~ (更快)
   #+begin_src java :classname 
     class Solution {
         public char firstUniqChar(String s) {
             if (s == null || s.length() <= 0) return ' ';
             int[] map = new int[95];
             int len = s.length();
             for (int i = 0; i < len; i++) {
                 int offset = s.charAt(i) - ' ';
                 map[offset] += 1;
             }
             for (int i = 0; i < len; i++) {
                 int offset = s.charAt(i) - ' ';
                 if (map[offset] == 1) return s.charAt(i);
             }
             return ' ';
         }
     }
   #+end_src 
** 2 字符流中第一个只出现一次的字符                         :UNRESOLVED:
* 51 数组中的逆序对                                                 :TOBEORG:
** 归并排序
*** 基于 ~Queue~ (递归，迭代不可行)
    #+begin_src java :classname 
      class Solution {
          private int N = 0;
          public int reversePairs(int[] nums) {
              if (nums == null || nums.length <= 1) return N;
              Queue<Integer> queue = new LinkedList<>(); //不能写成 new Queue<>(), 因为 Queue 是个接口，无构造函数．
              for (int i = 0; i < nums.length; i++) {
                  queue.add(nums[i]);
              }
              mergeSort(queue);
              return N;
          }

          private Queue<Integer> mergeSort(Queue<Integer> nums) {
              if (nums.size() <= 1) return nums;
              int len = nums.size();
              Queue<Integer> q1 = new LinkedList<>();
              Queue<Integer> q2 = new LinkedList<>();
              for (int i = 0; i < len/2; i++) {
                  q1.offer(nums.poll());
              }
              for (int i = len/2; i < len; i++) {
                  q2.offer(nums.poll());
              }
              return mergeSorted(mergeSort(q1), mergeSort(q2));

              // Queue<Queue<Integer>> queues = singleIntQueues(nums);
              // while (queues.size() > 1) {
              //     Queue<Integer> q1 = queues.poll();
              //     Queue<Integer> q2 = queues.poll();
              //     queues.offer(mergeSorted(q1,q2));
              // }
              // return queues.poll();
          }

          private Queue<Integer> mergeSorted(Queue<Integer> q1, Queue<Integer> q2) {
              Queue<Integer> sortedq = new LinkedList<>();
              while (!q1.isEmpty() || !q2.isEmpty()) {
                  sortedq.offer(getMin(q1, q2));
              }
              return sortedq;
          }

          private int getMin(Queue<Integer> q1, Queue<Integer> q2) {
              if (!q1.isEmpty() && !q2.isEmpty()) {
                  int n1 = q1.peek(), n2 = q2.peek();
                  if (n1 > n2) {
                      N += q1.size();
                      return q2.poll();
                  } else {
                      return q1.poll();
                  }
              } else if (q1.isEmpty()) {
                  return q2.poll();
              } else return q1.poll();
          }

          private Queue<Queue<Integer>> singleIntQueues(Queue<Integer> nums) {
              Queue<Queue<Integer>> queues = new LinkedList<>();
              for (Integer num : nums) {
                  Queue<Integer> que = new LinkedList<>();
                  que.offer(num);
                  queues.offer(que);
              }
              return queues;
          }
      }
    #+end_src 
*** 基于数组(递归)
    #+begin_src java :classname 
      class Solution {
          public int reversePairs(int[] nums) {
              if (nums == null || nums.length <= 1) return 0;
              int len = nums.length;
              int[] copy = new int[len];
              for (int i = 0; i < len; i++) {
                  copy[i] = nums[i];
              }
              return revHelper(nums, copy, 0, len-1);
          }

          private int revHelper(int[] nums, int[] copy, int start, int end) {
              if (start == end) {
                  copy[start] = nums[start];
                  return 0;
              }
              int mid = (start + end) / 2;
              int left = revHelper(copy, nums, start, mid);
              int right = revHelper(copy, nums, mid+1, end);

              int lStart = start, rStart = mid+1, copyStart = start, count = 0;
              while(lStart <= mid && rStart <= end) {
                  if (nums[lStart] > nums[rStart]) {
                      copy[copyStart++] = nums[rStart++];
                      count += mid - lStart + 1;
                  } else {
                      copy[copyStart++] = nums[lStart++];
                  }
              }
              while (lStart <= mid) {
                  copy[copyStart++] = nums[lStart++];
              }
              while (rStart <= end) {
                  copy[copyStart++] = nums[rStart++];
              }

              // int lEnd = mid, rEnd = end, copyEnd = end, count = 0;
              // while (lEnd >= start && rEnd >= mid+1) {
              //     if (nums[lEnd] > nums[rEnd]) {
              //         copy[copyEnd--] = nums[lEnd--];
              //         count += rEnd - mid;
              //     } else {
              //         copy[copyEnd--] = nums[rEnd--];
              //     }
              // }
              // while (lEnd >= start) {
              //     copy[copyEnd--] = nums[lEnd--];
              // }
              // while (rEnd >= mid+1) {
              //     copy[copyEnd--] = nums[rEnd--];
              // }

              return left + right + count;
          }
      }
    #+end_src 
*** Question:                                                     :QUESTIONS:
    - [ ] 基于 *数组* 的 *递归归并排序* 进一步理解
      - [ ] 函数签名 ~revHelper(int[] nums, int[] copy, int start, int end)~ 的设计
      - [ ] ~nums~ 和 ~copy~ 两个数组的关系，为什么 ~copy~ 要这样初始化?
      - [ ] 在数组上如何利用 ~nums~, ~copy~, ~start~ 和 ~end~ 完成排序？即 *数组* 往往和 *指针* (索引)配合，联系 [[ilink24][基于数组的快排]]
      - [ ] 对比基于 ~Queue~ 的归并，能否设计更 *模块化* ，更易读的辅助函数?
** 树状数组                                                      :UNRESOLVED:
   #+begin_src python :results output
     class Solution:
         def reversePairs(self, nums: List[int]) -> int:

             class FenwickTree:
                 def __init__(self, n):
                     self.size = n
                     self.tree = [0 for _ in range(n + 1)]

                 def __lowbit(self, index):
                     return index & (-index)

                 # 单点更新：从下到上，最多到 len，可以取等
                 def update(self, index, delta):
                     while index <= self.size:
                         self.tree[index] += delta
                         index += self.__lowbit(index)

                 # 区间查询：从上到下，最少到 1，可以取等
                 def query(self, index):
                     res = 0
                     while index > 0:
                         res += self.tree[index]
                         index -= self.__lowbit(index)
                     return res

             # 特判
             size = len(nums)
             if size < 2:
                 return 0

             # 原始数组去除重复以后从小到大排序，这一步叫做离散化
             s = list(set(nums))

             # 构建最小堆，因为从小到大一个一个拿出来，用堆比较合适
             import heapq
             heapq.heapify(s)

             # 由数字查排名
             rank_map = dict()
             rank = 1
             # 不重复数字的个数
             rank_map_size = len(s)
             for _ in range(rank_map_size):
                 num = heapq.heappop(s)
                 rank_map[num] = rank
                 rank += 1

             res = 0
             # 树状数组只要不重复数字个数这么多空间就够了
             ft = FenwickTree(rank_map_size)

             # 从后向前看，拿出一个数字来，就更新一下，然后向前查询比它小的个数
             for i in range(size - 1, -1, -1):
                 rank = rank_map[nums[i]]
                 ft.update(rank, 1)
                 res += ft.query(rank - 1)
             return res
   #+end_src 
* 52 两个链表的第一个公共节点                                       :TOBEORG:
** 辅助栈
   #+begin_src java :classname 
     public class Solution {
         public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
             ListNode common = null;
             Stack<ListNode> a = new Stack<>();
             Stack<ListNode> b = new Stack<>();
             ListNode p = headA, q = headB;
             while (p != null) {
                 a.push(p);
                 p = p.next;
             }
             while (q != null) {
                 b.push(q);
                 q = q.next;
             }
             while (!a.empty() && !b.empty() && a.peek() == b.peek()) {
                 common = a.pop();
                 b.pop();
             }
             return common;
         }
     }
   #+end_src 
** 预遍历同步
   #+begin_src java :classname 
     public class Solution {
         public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
             if (headA == null || headB == null) return null;
             int lenA = 0, lenB = 0;
             ListNode pA = headA, pB = headB;
             while (pA != null) {
                 lenA += 1;
                 pA = pA.next;
             }
             while (pB != null) {
                 lenB += 1;
                 pB = pB.next;
             }
             pA = headA;
             pB = headB;
             if (lenA > lenB) {
                 for (int i = 0; i < lenA - lenB; i++) {
                     pA = pA.next;
                 }
             } else {
                 for (int i = 0; i < lenB - lenA; i++) {
                     pB = pB.next;
                 }
             }
             while (pA != null && pB != null) {
                 if (pA == pB) return pA;
                 pA = pA.next;
                 pB = pB.next;
             }
             return null;
         }
     }
   #+end_src 
** 双指针相遇
   #+begin_src java :classname 
     public class Solution {
         public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
             if (headA == null || headB == null) return null;
             ListNode p1 = headA, p2 = headB;
             while (p1 != p2) {
                 p1 = p1 != null ? p1.next : headB;
                 p2 = p2 != null ? p2.next : headA;
             }
             return p1;
         }
     }
   #+end_src 
* 53 在排序数组中查找数字                                           :TOBEORG:
** 1 数字在排序数组中出现的次数
*** 递归
    #+begin_src java :classname 
      class Solution {
          public int search(int[] nums, int target) {
              if (nums == null || nums.length <= 0) return 0;
              int start = getFirst(nums, target, 0, nums.length - 1);
              int end = getLast(nums, target, 0, nums.length - 1);
              if (start != -1 && end != -1) return end - start + 1;
              return 0;
          }

          private int getFirst(int[] nums, int target, int start, int end) {
              if (start > end) return -1;
              int mid = (start + end) / 2;
              if (nums[mid] < target) start = mid + 1;
              else if (nums[mid] > target) end = mid - 1;
              else {
                  if (mid == 0 || nums[mid-1] != target) return mid;  
                  end = mid - 1;
              } 
              return getFirst(nums, target, start, end);
          }

          private int getLast(int[] nums, int target, int start, int end) {
              if (start > end) return -1;
              int mid = (start + end) / 2;
              if (nums[mid] < target) start = mid + 1;
              else if (nums[mid] > target) end = mid - 1;
              else {
                  if (mid == nums.length-1 || nums[mid+1] != target) return mid;   
                  start = mid + 1;
              }
              return getLast(nums, target, start, end);
          }
      }
    #+end_src 
*** 迭代
    #+begin_src java :classname 
      class Solution {
          public int search(int[] nums, int target) {
              if (nums == null || nums.length <= 0) return 0;
              int len = nums.length, start = 0, end = len - 1, mid = (start + end) / 2;
              while (nums[mid] != target) {
                  if (nums[mid] < target) start = mid + 1;
                  else end = mid - 1;
                  if (start > end) return 0;
                  mid = (start + end) / 2;
              }
              int startL = 0, endL = mid, midL = (startL + endL) / 2;
              while (!isStart(nums, midL, target)) {
                  if (nums[midL] == target) endL = midL - 1;
                  else startL = midL + 1;
                  midL = (startL + endL) / 2;
              }
              int startR = mid, endR = len - 1, midR = (startR + endR) / 2;
              while (!isEnd(nums, midR, target)) {
                  if (nums[midR] == target) startR = midR + 1;
                  else endR = midR - 1;
                  midR = (startR + endR) / 2;
              }
              return midR - midL + 1;
          }
          private boolean isStart(int[] nums, int mid, int target) {
              return nums[mid] == target && (mid == 0 || nums[mid-1] != target);
          }

          private boolean isEnd(int[] nums, int mid, int target) {
              return nums[mid] == target && (mid == nums.length-1 || nums[mid+1] != target);
          }
      }
    #+end_src 
*** Question:                                                     :QUESTIONS:
    - [ ] 联系 [[ilink1][二分查找1]] [[ilink15][二分查找2]] 关于 *二分查找索引更新* 和 ~mid~ 位置的思考
      - [ ] 索引更新
        - [ ] 已知存在: ~start = mid or mid + 1~ ~end = mid or mid - 1~
        - [ ] 不一定存在: ~start = mid + 1~ ~end = mid - 1~ 
      - [ ] ~mid~ 在 *奇数* 长度时处于中间， *偶数* 长度处于 *前or后半段*, 取决于 ~end~ 的选择 ~len or len - 1~ 
      - [ ] 不同的索引更新策略与的相应 ~mid~ 特点有什么关系?
    - [ ] 基于以上结论实现迭代版本
** 2 0~n-1中缺失的数字
*** 迭代
    #+begin_src java :classname 
      class Solution {
          public int missingNumber(int[] nums) {
              int len = nums.length;
              if (nums[0] == 1) return 0;
              if (nums[len-1] == len - 1) return len;
              int start = 0, end = len - 1, mid = (start + end) / 2;
              while (!(nums[mid] == mid && nums[mid+1] > mid+1)) {
                  if (nums[mid] == mid) start = mid + 1;
                  else end = mid - 1;
                  mid = (start + end) / 2;
              }
              return mid + 1;
          }
      }
    #+end_src 
*** 递归
    #+begin_src java :classname 
      class Solution {
          public int missingNumber(int[] nums) {
              int len = nums.length;
              if (nums[0] == 1) return 0;
              if (nums[len-1] == len - 1) return len;
              return helper(nums, 0, len - 1);
          }

          private int helper(int[] nums, int start, int end) {
              int mid = (start + end) / 2;
              if (nums[mid] == mid && nums[mid+1] > mid+1) return mid + 1;
              if (nums[mid] == mid) start = mid + 1;
              else end = mid - 1;
              return helper(nums, start, end);
          }
      }
    #+end_src 
* 54 二叉搜索树的第k大节点                                     :TREE:TOBEORG:
** 递归
   #+begin_src java :classname 
     class Solution {
         private int count = 0;
         private int val = 0;
         public int kthLargest(TreeNode root, int k) {
             if (root != null) helper(root, k);
             return val;

             // return helper(root, k);
         }

         private void helper(TreeNode root, int k) {
             if (root.right != null) helper(root.right, k);
             if (count != k) {
                 count += 1;
                 if (count == k) val = root.val;
             }
             if (count != k && root.left != null) helper(root.left, k);
         }

         // private int helper(TreeNode root, int k) {
         //     if (root.right != null) val = helper(root.right, k);
         //     if (count != k) {
         //         count += 1;
         //         if (count == k) val = root.val;
         //     }
         //     if (count != k && root.left != null) val = helper(root.left, k);
         //     return val;
         // }
     }
   #+end_src 
*** Question:                                                     :QUESTIONS:
    - [ ] 联系 [[elink6][offer34]] 有关递归有无返回，有无成员变量辅助记录的思考
    - [ ] 体会判断 ~count != k~ 在 *递归过程* 中的 *控制* 作用
** 迭代
   #+begin_src java :classname 
     class Solution {
         public int kthLargest(TreeNode root, int k) {
             int count = 1;
             Stack<TreeNode> stack = new Stack<>();
             // while (Objects.nonNull(root) || !stack.empty()) {
             while (root != null || !stack.empty()) {
                 // while (Objects.nonNull(root)) {
                 while (root != null) {
                     stack.push(root);
                     root = root.right;
                 }
                 TreeNode pop = stack.pop();
                 if (count == k) {
                     return pop.val;
                 }
                 count++;
                 root = pop.left;
             }
             return 0;
         }
     }
   #+end_src 
*** Question:                                                     :QUESTIONS:
    - [ ] 关于树的前 中 后 层序遍历的递归和迭代对比整理？
    - [ ] 以上用 ~Queue~ 实现?
* 55 二叉树的深度                                              :TREE:TOBEORG:
** 1 二叉树的深度
   #+begin_src java :classname 
     class Solution {
         public int maxDepth(TreeNode root) {
             if (root == null) return 0;
             // if (root.left == null && root.right == null) return 1;
             int lmaxDepth = maxDepth(root.left);
             int rmaxDepth = maxDepth(root.right);
             return lmaxDepth > rmaxDepth ? lmaxDepth + 1 : rmaxDepth + 1;
         }
     }
   #+end_src 
** 2 平衡二叉树
*** 递归
    - 直接递归(前序遍历，易读但重复遍历，效率低)
      #+begin_src java :classname 
        class Solution {
            public boolean isBalanced(TreeNode root) {
                if (root == null) return true;
                int diff = maxDepth(root.left) - maxDepth(root.right);
                return (diff <= 1 && diff >= -1) && isBalanced(root.left) && isBalanced(root.right);
            }
  
            private int maxDepth(TreeNode root) {
                if (root == null) return 0;
                // if (root.left == null && root.right == null) return 1;
                int lmaxDepth = maxDepth(root.left);
                int rmaxDepth = maxDepth(root.right);
                return lmaxDepth > rmaxDepth ? lmaxDepth + 1 : rmaxDepth + 1;
            }
  
        }
      #+end_src
    - 优化递归(后序遍历避免重复遍历)
      #+begin_src java :classname 
        class Solution {
            public boolean isBalanced(TreeNode root) {
                return isBalancedHelper(root, new int[1]);
            }

            private boolean isBalancedHelper(TreeNode root, int[] maxDepth) {
                if (root == null) {
                    maxDepth[0] = 0;
                    return true;
                }
                int[] left = new int[1], right = new int[1];
                if (isBalancedHelper(root.left, left) && isBalancedHelper(root.right, right)) {
                    int diff =  left[0] - right[0];
                    if (diff >= -1 && diff <= 1) {
                        maxDepth[0] = left[0] > right[0] ? left[0] + 1 : right[0] + 1;
                        return true;
                    }
                }
                return false;
            }
        }
      #+end_src
*** Question:                                                     :QUESTIONS:
    - [ ] 对比前序遍历和后序遍历的 *递归过程*
      - [ ] 后序便利递归如何把 *最大深度* 和 *子树平衡* 两个递归过程 *结合* 起来的?
      - [ ] 联系之前 *递归遍历过程* 对比思考: 前序递归(子上而下 重复) 后序递归(自下而上 不重复) 回溯
* 56 数组中数字出现的次数                                     :ARRAY:TOBEORG:
** 1 数组中只出现一次的两个数字
   #+begin_src java :classname 
     class Solution {
         public int[] singleNumbers(int[] nums) {
             if (nums.length == 2) return nums;
             int[] single = new int[2];
             int xorResult = 0, len = nums.length;
             for (int i = 0; i < len; i++) {
                 xorResult ^= nums[i];
             }
             int first = 0;
             while ((xorResult & 1) == 0) {
                 xorResult = xorResult >> 1;
                 first += 1;
             }
             for (int i = 0; i < len; i++) {
                 if (((nums[i]>>first) & 1) == 0) single[0] ^= nums[i];
                 else single[1] ^= nums[i];
             }
             return single;
         }
     }
   #+end_src 
** 2 数组中唯一只出现一次的数字
*** 二进制表示法
    #+begin_src java :classname 
      class Solution {
          public int singleNumber(int[] nums) {
              if (nums.length == 1) return nums[0];
              int[] bitSum = new int[32];
              int len = nums.length;
              for (int i = 0; i < len; i++) {
                  int bitNum = 1;
                  for (int j = 0; j < 32; j++) {
                      if ((nums[i] & bitNum) != 0) bitSum[j] += 1;
                      bitNum = bitNum << 1;
                  }
              }

              int result = 0;
              for (int i = 31; i >= 0; i--) {
                  result = result << 1;
                  result += bitSum[i] % 3;
              }
              return result;
          }
      }
    #+end_src 
*** 状态机                                                       :UNRESOLVED:
    #+begin_src java :classname 
      class Solution {
          public int singleNumber(int[] nums) {
              int a=0,b=0;
              for (int c : nums) {
                  b = b ^ c & ~ a;
                  a = a ^ c & ~ b;
              }
              return b;
          }
      }
    #+end_src 
* 57 和为s的数字                                             :STRING:TOBEORG:
** 1 和为s的两个数字
*** 双指针
    #+begin_src java :classname 
      class Solution {
          public int[] twoSum(int[] nums, int target) {
              if (nums == null || nums.length <= 1) return null;
              int len = nums.length, p1 = 0, p2 = len - 1;
              while (nums[p1] + nums[p2] != target) {
                  if (nums[p1]+nums[p2] > target) p2 -= 1;
                  else p1 += 1;
                  if (p1 > p2) return null;
              }
              return new int[] {nums[p1], nums[p2]};
          }
      }
    #+end_src 
*** ~HashMap~
    #+begin_src java :classname 
      class Solution {
          public int[] twoSum(int[] nums, int target) {
              if (nums == null || nums.length <= 1) return null;
              HashMap<Integer, Integer> map = new HashMap<>();
              int len = nums.length;
              map.put(nums[0], 0);
              for (int i = 1; i < len; i++) {
                  int diff = target - nums[i];
                  if (map.containsKey(diff)) return new int[] {nums[map.get(diff)], nums[i]};
                  map.put(nums[i], i);
              }
              return null;
          }
      }
    #+end_src 
** 2 和为s的连续整数序列
*** 公式推导遍历(利用 ~TreeMap~ )
    #+begin_src java :classname 
      class Solution {
          public int[][] findContinuousSequence(int target) {
              if (target < 3) return null;
              Map<Integer, Integer> map = new TreeMap<>();
              // Map<Integer, Integer> map = new HashMap<>();
              for (int n = 2; n <= target; n += 1) {
                  int x = target - n*(n-1)/2;
                  if (x <= 0) break;
                  if (x % n != 0) continue;
                  map.put(x/n, n);
              }
              int[][] results = new int[map.size()][];
              int index = 0;
              for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                  int[] result = new int[entry.getValue()];
                  for (int i = 0; i < result.length; i++) {
                      result[i] = entry.getKey() + i;
                  }
                  results[index] = result;
                  index += 1;
              }
              return results;
          }
      }
    #+end_src 
*** 滑动窗口(双指针)
    #+begin_src java :classname 
      class Solution {
          public int[][] findContinuousSequence(int target) {
              if (target < 3) return null;
              int left = 1, right = 2, sum = left + right;
              List<int[]> results = new ArrayList<>();
              while (left < (target+1) / 2) {
              // while (left <= target / 2) {
                  if (sum < target) {
                      right++;
                      sum += right;
                  } else if (sum > target) {
                      sum -= left;
                      left++;
                  } else {
                      int[] result = new int[right-left+1];
                      for (int i = 0; i < result.length; i++) {
                          result[i] = i + left;
                      }
                      results.add(result);
                      sum -= left;
                      left++;
                  }
              }
              return results.toArray(new int[results.size()][]);
          }
      }
    #+end_src 
**** Question:                                                    :QUESTIONS:
     - [ ] 联系对比之前的双指针 三指针 滑动窗口在数组问题中的应用
* 58 翻转字符串                                              :STRING:TOBEORG:
** 1 翻转单词顺序
*** 使用 ~StringBuilder~ 
    #+begin_src java :classname 
      class Solution {
          public String reverseWords(String s) {
              String[] words = s.trim().split(" ");
              // String[] words = s.trim().split(" +");
              StringBuilder reverse = new StringBuilder();
              for (int i = words.length-1; i >= 0; i--) {
                  if (words[i].equals("")) continue;
                  reverse.append(words[i].trim());
                  if (i != 0) reverse.append(" ");
              }
              return reverse.toString();
          }
      }
    #+end_src 
*** 两轮翻转                                                     :UNRESOLVED:
*** Question:                                                     :QUESTIONS:
    - [ ] 为何用正则表达式 ~split(" +")~ 会慢?
    - [ ] java的两轮翻转效率实现?
** 2 左旋转字符串
*** 使用 ~StringBuilder~ 
    #+begin_src java :classname 
      class Solution {
          public String reverseLeftWords(String s, int n) {
              if (s == null || s.length() < n) return null;
              StringBuilder str = new StringBuilder();
              str.append(s.substring(n));
              str.append(s.substring(0, n));
              return str.toString();
          }
      }
    #+end_src 
*** 3次翻转
    #+begin_src java :classname 
      class Solution {
          public String reverseLeftWords(String s, int n) {
              if (s == null || s.length() < n) return null;
              char[] ch = s.toCharArray();
              reverse(ch, 0, n-1);
              reverse(ch, n, ch.length-1);
              reverse(ch, 0, ch.length-1);
              return new String(ch);
          }

          private void reverse(char[] ch, int i, int j) {
              while (i < j) {
                  char temp = ch[i];
                  ch[i] = ch[j];
                  ch[j] = temp;
                  i += 1;
                  j -= 1;
              }
          }
      }
    #+end_src 
* 59 队列的最大值                                             :QUEUE:TOBEORG:
** 1 滑动窗口的最大值
*** 蛮力优化
    #+begin_src java :classname 
      class Solution {
          public int[] maxSlidingWindow(int[] nums, int k) {
              if (nums == null || nums.length <= 0 || k <= 0) return new int[0];
              int len = nums.length;
              int[] maxVals = new int[len-k+1];
              maxVals[0] = maxVal(nums, 0, k);
              for (int i = 1; i < maxVals.length; i++) {
                  if (nums[i-1+k] >= maxVals[i-1]) {
                      maxVals[i] = nums[i-1+k];
                      continue;
                  }
                  maxVals[i] = maxVals[i-1] == nums[i-1] ? maxVal(nums, i, i+k) : maxVals[i-1];
              }
              return maxVals;
          }

          private int maxVal(int[] nums, int start, int end) {
              int max = nums[start];
              for (int i = start+1; i < end; i++) {
                  if (nums[i] > max) max = nums[i];
              }
              return max;
          }
      }
    #+end_src 
*** 滑动窗口最大值 -> 能记录最大值的队列
**** 利用 ~Deque~ 在队顶维持最大值
     #+begin_src java :classname 
       class Solution {
           public int[] maxSlidingWindow(int[] nums, int k) {
               if (nums == null || nums.length <= 0 || k <= 0) return new int[0];
               int len = nums.length;
               int[] maxVals = new int[len-k+1];
               Deque<Integer> dq = new LinkedList<>();
               for (int i = 0; i < k; i++) {
                   while (!dq.isEmpty() && nums[dq.getLast()] <= nums[i]) {
                       dq.removeLast();
                   }
                   dq.addLast(i);
               }

               maxVals[0] = nums[dq.getFirst()];
               for (int i = k; i < len; i++) {
                   while (!dq.isEmpty() && nums[i] >= nums[dq.getLast()]) {
                       dq.removeLast();
                   }
                   dq.addLast(i);
                   if (!dq.isEmpty() && i-dq.getFirst() >= k) dq.removeFirst();
                   maxVals[i-k+1] = nums[dq.getFirst()];
               }

               // for (int i = k; i < len; i++) {
               //     maxVals[i-k] = nums[dq.getFirst()];
               //     while (!dq.isEmpty() && nums[i] >= nums[dq.getLast()]) {
               //         dq.removeLast();
               //     }
               //     dq.addLast(i);
               //     if (!dq.isEmpty() && i-dq.getFirst() >= k) dq.removeFirst();
               // }
               // maxVals[len-k] = nums[dq.getFirst()];
               return maxVals;
           }
       }
     #+end_src 
**** 利用 [[ilink25][offer8]] 和 [[ilink26][offer30]]                                      :UNRESOLVED:
** 2 队列的最大值
*** 借助记录 ~currIndex~, ~maxDQ~ 能够只维持 *最新的不重复的* 最大值( ~>=~ 时更新)
    #+begin_src java :classname 
      class MaxQueue {
          class Pair {
              int data;
              int index;
              Pair(int d, int i) {
                  data = d;
                  index = i;
              }
          }

          private Queue<Pair> dataQue;
          private Deque<Pair> maxDQ;
          private int currIndex;

          public MaxQueue() {
              dataQue = new LinkedList<>();
              maxDQ = new LinkedList<>();
              currIndex = 0;
          }

          public int max_value() {
              if (dataQue.isEmpty() || maxDQ.isEmpty()) return -1;
              return maxDQ.getFirst().data;
          }

          public void push_back(int value) {
              while (!maxDQ.isEmpty() && value >= maxDQ.getLast().data) {
                  maxDQ.removeLast();
              }
              Pair p = new Pair(value, currIndex);
              dataQue.offer(p);
              maxDQ.addLast(p);
              currIndex += 1;
          }

          public int pop_front() {
              if (dataQue.isEmpty() || maxDQ.isEmpty()) return -1;
              Pair p = dataQue.poll();
              if (p.index == maxDQ.getFirst().index) maxDQ.removeFirst();
              return p.data;
          }
      }
    #+end_src 
*** ~maxDQ~ 维持 *重复的* 最大值( ~>~ 时才更新)
    #+begin_src java :classname 
      class MaxQueue {

          private Queue<Integer> dataQue;
          private Deque<Integer> maxDQ;

          public MaxQueue() {
              dataQue = new LinkedList<>();
              maxDQ = new LinkedList<>();
          }

          public int max_value() {
              if (dataQue.isEmpty() || maxDQ.isEmpty()) return -1;
              return maxDQ.getFirst();
          }

          public void push_back(int value) {
              while (!maxDQ.isEmpty() && value > maxDQ.getLast()) {
                  maxDQ.removeLast();
              }
              dataQue.offer(value);
              maxDQ.addLast(value);
          }

          public int pop_front() {
              if (dataQue.isEmpty() || maxDQ.isEmpty()) return -1;
              int val = dataQue.poll();
              if (val == maxDQ.getFirst()) maxDQ.removeFirst();
              return val;
          }
      }
    #+end_src 
*** Question:                                                     :QUESTIONS:
    - [ ] 以上两种实际中那种比较合适? 一个节省空间一个节省时间?
* 60 n个骰子的点数                                                  :TOBEORG:
** 递归                                                          :UNRESOLVED:
   #+begin_src java :classname 
     class Solution {
         private static final int maxValue = 6;
         public double[] twoSum(int n) {
             if (n <= 0) return null;
             int[] events = new int[n*maxValue-n+1];
             Events(events, n);
             double totalEvents = Math.pow((double) maxValue, (double) n);
             double[] probs = new double[events.length];
             for (int i = 0; i < events.length; i++) {
                 probs[i] = events[i] / totalEvents;
             }
             return probs;
         }

         private void Events(int[] events, int n) {
             for (int i = 1; i <= maxValue; i++) {
                 Events(n, n, i, events);
             }
         }

         private void Events(int total, int remain, int sum, int[] events) {
             if (remain == 1) events[sum-total]++;
             else {
                 for (int i = 1; i <= maxValue; i++) {
                     Events(total, remain-1, sum+i, events);
                 }
             }
         }
     }
   #+end_src 
** 迭代(DP)
*** 用二维数组
    #+begin_src java :classname 
      class Solution {
          private static final int maxValue = 6;
          public double[] twoSum(int n) {
              if (n <= 0) return null;
              int[][] events = new int[n+1][n*maxValue+1];
              for (int i = 1; i <=6; i++) {
                  events[1][i] = 1;
              }
              for (int i = 2; i <= n; i++) {
                  for (int j = i; j <= i*maxValue; j++){
                      for (int k = 1; k < j && k <= 6; k++) {
                          events[i][j] += events[i-1][j-k];
                      }
                  }
              }
              double totalEvents = Math.pow((double)maxValue, (double)n);
              double[] probs = new double[n*maxValue-n+1];
              for (int i = 0; i < probs.length; i++) {
                  probs[i] = events[n][i+n] / totalEvents;
              }
              return probs;
          }
      }
    #+end_src
*** 用一维数组(空间优化)                                         :UNRESOLVED:
    #+begin_src java :classname 
      class Solution {
          public double[] twoSum(int n) {
              double[] pd = new double[n * 6 + 1];
              pd[0] = 1;
              for (int i = 1; i <= n; i++) {
                  for (int j = i * 6; j >= i; j--) {
                      pd[j] = 0;
                      for (int k = i - 1; k < j && k <= (i - 1) * 6; k++) {
                          if (j - k <= 6) {
                              pd[j] += pd[k] * 1.0 / 6;
                          }
                      }
                  }
              }
              double[] ans = new double[n * 6 - n + 1];
              for (int i = 0; i < ans.length; i++) ans[i] = pd[i + n];
              return ans;
          }
      }
    #+end_src 
** Question:                                                      :QUESTIONS:
   - [ ] 递归法的进一步理解?
   - [ ] 空间优化?
* 61 扑克牌中的顺子                                           :ARRAY:TOBEORG:
** 先排序
   #+begin_src java :classname 
     class Solution {
         public boolean isStraight(int[] nums) {
             int zeros = 0, gap = 0, len = nums.length;
             Arrays.sort(nums);
             for (int i = 0; i < len-1; i++) {
                 if (nums[i] == 0) zeros += 1;
                 else {
                     int x = nums[i+1] - nums[i];
                     if (x == 0) return false;
                     // if (x > 1) gap += x-1;
                     gap += x-1;
                 }
             }
             return zeros >= gap;
         }
     }
   #+end_src 
** 不排序                                                        :UNRESOLVED:
   #+begin_src C 
     class Solution {
      public:
       bool isStraight(vector<int>& nums) {
         bool m[15];
         memset(m, 0, sizeof(m));
         int minValue = 14, maxValue = 0;
         for (int item : nums) {
           if (item == 0) {
             continue;
           }
           if (m[item]) {
             return false;
           }
           m[item] = true;
           minValue = min(minValue, item);
           maxValue = max(maxValue, item);            
         }
         return maxValue - minValue + 1 <= 5;
       }
     };
   #+end_src
* 62 圆圈中最后剩下的数字                                           :TOBEORG:
** 数学递推公式
   #+begin_src java :classname 
     class Solution {
         public int lastRemaining(int n, int m) {
             if (n < 1 || m < 1) return -1;
             if (n == 1) return 0;
             // return (lastRemaining(n-1, m) + m) % n;
             int last = 0;
             for (int i = 2; i <= n; i++) {
                 last = (last+m) % i;
             }
             return last;
         }
     }
   #+end_src 
*** Question:                                                     :QUESTIONS:
    - [ ] 约瑟夫环递推式推导?
** 用链表模拟                                                    :UNRESOLVED:
   #+begin_src java :classname 
     class Solution {
         public int lastRemaining(int n, int m) {
             if(n==0||m==0)
                 return -1;
             List<Integer> list=new ArrayList<>();
             for(int i=0;i<n;i++)
                 list.add(i);
             int c=(m-1)%n;
             while(list.size()!=1) {
                 list.remove(c);
                 c=(c+m-1)%list.size();  
             }
             return list.get(0);
         }
     }
   #+end_src 
* 63 股票的最大利润                                           :ARRAY:TOBEORG:
  #+begin_src java :classname 
    class Solution {
        public int maxProfit(int[] prices) {
            if (prices == null || prices.length <= 1) return 0;
            int len = prices.length, min = prices[0], maxprofit = 0;
            for (int i = 1; i < len; i++) {
                if (maxprofit < prices[i]-min) maxprofit = prices[i] - min;
                if (prices[i] < min) min = prices[i];
            }
            return maxprofit;
        }
    }
  #+end_src 
* 64 求1+2+...+n                                                    :TOBEORG:
** 作弊
   #+begin_src java :classname 
     class Solution {
         public int sumNums(int n) {
             return ((int) Math.pow(n, 2.0) + n) >> 1;
         }
     }
   #+end_src 
** ~&&~ 短路特性+递归
   #+begin_src java :classname 
     class Solution {
         public int sumNums(int n) {
             boolean x = (n > 0) && ((n += sumNums(n-1)) > 0);
             return n;
         }
     }
   #+end_src 
* 65 不用加减乘除做加法
  #+begin_src java :classname 
    class Solution {
        public int add(int a, int b) {
            int sum, carry;
            sum = a ^ b;
            carry = (a & b) << 1;
            a = sum;
            b = carry;
            while (b != 0) {
                sum = a ^ b;
                carry = (a & b) << 1;
                a = sum;
                b = carry;
            }
            return a;
        }
    }
  #+end_src 
* 66 构建乘积数组                                             :ARRAY:TOBEORG:
** 对称遍历
   #+begin_src java :classname 
     class Solution {
         public int[] constructArr(int[] a) {
             // if (a == null || a.length <= 1) return new int[0];
             if (a == null || a.length <= 1) return new int[] {};
             int len = a.length;
             int[] result = new int[len];
             result[0] = 1;
             for (int i = 1; i < len; i++) {
                 result[i] = a[i-1] * result[i-1];
             }
             int temp = 1;
             for (int i = len-2; i >= 0; i--) {
                 temp *= a[i+1];
                 result[i] *= temp;
             }
             return result;
         }
     }
   #+end_src 
** 左右数组(矩阵)
   #+begin_src java :classname 
     class Solution {
         public int[] constructArr(int[] a) {
             // if (a == null || a.length <= 1) return new int[0];
             if (a == null || a.length <= 1) return new int[] {};
             int len = a.length;
             int[] left = new int[len], right = new int[len], result = new int[len];
             left[0] = 1; right[len-1] = 1;
             for (int i = 1; i < len; i++) {
                 left[i] = left[i-1] * a[i-1];
                 right[len-1-i] = right[len-i] * a[len-i];
             }
             for (int i = 0; i < len; i++) {
                 result[i] = left[i] * right[i];
             }
             return result;
         }
     }
   #+end_src
* 67 把字符串转换成整数                                      :STRING:TOBEORG:
** 正确做法
   #+begin_src java :classname 
     class Solution {
         public int strToInt(String str) {
             int val = 0, i = 0;
             long longVal = 0;
             if (str != null && !str.isEmpty() && !str.trim().isEmpty()) {
                 str = str.trim();
                 boolean neg = str.charAt(0) == '-';
                 if (neg || str.charAt(0) == '+') i = 1;
                 for (; i < str.length(); i++) {
                     int x = str.charAt(i) - '0';
                     if (x >= 0 && x <= 9) {
                         longVal = longVal * 10 + x;
                         if (neg && -1*longVal <= Integer.MIN_VALUE) return Integer.MIN_VALUE;
                         if (!neg && longVal >= Integer.MAX_VALUE) return Integer.MAX_VALUE;
                         val = (int) longVal;
                         continue;
                     }
                     break;
                 }
                 val = neg ? -1*val : val;
             }
             return val;
         }
     }
   #+end_src 
** 借用 ~Long.parseLong~ (存在 ~Long~ 越界测试)
   #+begin_src java :classname 
     class Solution {
         public int strToInt(String str) {
             int val = 0;
             if (str != null && !str.isEmpty() && !str.trim().isEmpty()) {
                 str = str.trim();
                 int start = (str.charAt(0) == '-' || str.charAt(0) == '+') ? 1 : 0;
                 int end = start;
                 for (; end < str.length(); end++) {
                     char ch = str.charAt(end);
                     int x = ch - '0';
                     if (x >= 0 && x <= 9) continue;
                     break;
                 }
                 String nums = str.substring(start, end);
                 Long longVal = nums.isEmpty() ? 0 : Long.parseLong(nums);
                 if (str.charAt(0) == '-') longVal *= -1;
                 if (longVal < Integer.MIN_VALUE) val = Integer.MIN_VALUE;
                 else if (longVal > Integer.MAX_VALUE) val =  Integer.MAX_VALUE;
                 else val =  longVal.intValue();
             }
             return val;
         }
     }
   #+end_src 
** Question:                                                      :QUESTIONS:
   - [ ] 联系对比 [[ilink28][offer20]] [[ilink29][offer46]] 
* 68 树中两个节点的最低公共祖先                                :TREE:TOBEORG:
** 1 二叉搜索树的最近公共祖先
*** 二叉树性质
**** 迭代
     #+begin_src java :classname 
       class Solution {
           public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
               if (p.val == root.val || q.val == root.val) return root;
               TreeNode n = root;
               while ((p.val < n.val && q.val < n.val) || (p.val > n.val && q.val > n.val)) {
                   if (p.val < n.val && q.val < n.val) n = n.left;
                   else n = n.right;
               }
               return n;
           }
       }
     #+end_src 
**** 递归
     #+begin_src java :classname 
       class Solution {
           public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
               if (p.val == root.val || q.val == root.val) return root;
               if ((p.val < root.val && q.val > root.val) || (p.val > root.val && q.val < root.val)) return root;
               if (p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p, q);
               else return lowestCommonAncestor(root.right, p, q);
           }
       }
     #+end_src 
*** 利用 ~HashMap~ 模拟过程
    #+begin_src java :classname 
      class Solution {
          public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
              if (p.val == root.val || q.val == root.val) return root;
              HashMap<Integer, TreeNode> map = new HashMap<>();
              TreeNode n = root, lowCA = root;
              while (n.val != p.val) {
                  map.put(n.val, n);
                  if (p.val < n.val) n = n.left;
                  else n = n.right;
              }
              map.put(p.val, p);
              n = root;
              while (n.val != q.val) {
                  if (map.containsKey(n.val)) lowCA = map.get(n.val);
                  if (q.val < n.val) n = n.left;
                  else n = n.right;
              }
              if (map.containsKey(q.val)) lowCA = map.get(q.val);
              return lowCA;
          }
      }
    #+end_src 
** 2 二叉树的最近公共祖先
*** 递归
**** dfs *打印路径* 转化为 *链表分叉口* (逆过来即相遇点)问题
     #+begin_src java :classname 
       class Solution {
           public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
               List<TreeNode> pathp = new ArrayList<>();
               List<TreeNode> pathq = new ArrayList<>();
               dfs(root, p, pathp);
               dfs(root, q, pathq);
               TreeNode lowCA = root;
               for (int i = 0; ;i++) {
                   if (pathp.size()-1 < i || pathq.size()-1 < i) break;
                   TreeNode n1 = pathp.get(i);
                   TreeNode n2 = pathq.get(i);
                   if (n1.val == n2.val) lowCA = n1;
                   else break;
               }
               return lowCA;
           }

           private boolean dfs(TreeNode root, TreeNode n, List<TreeNode> path) {
               if (root == null) return false;
               path.add(root);
               if (root.val == n.val) return true;
               boolean left = dfs(root.left, n, path);
               boolean right = dfs(root.right, n ,path);
               if (!left && !right) path.remove(path.size()-1);
               return left || right;
           }
       }
     #+end_src 
**** 后序遍历
     #+begin_src java :classname 
       class Solution {
           public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
               if (root==null || root==p || root==q) return root;

               TreeNode leftNode = lowestCommonAncestor(root.left, p, q);
               TreeNode rightNode = lowestCommonAncestor(root.right, p, q);

               if (leftNode == null) return rightNode;
               if (rightNode == null) return leftNode;

               return root;
           }
       }
     #+end_src 
*** 迭代(打印路径)                                               :UNRESOLVED:
    #+begin_src C 
      class Solution {
      public:
          void getPath(TreeNode *root, TreeNode *end, vector<TreeNode*>& path) {
              stack<TreeNode*> stk;
              TreeNode *p = root, *prev = nullptr;
              while (p || !stk.empty()) {
                  while (p) {
                      stk.push(p);
                      path.push_back(p);
                      if (p == end) return;
                      p = p->left;
                  }
                  p = stk.top();
                  if (!p->right || p->right == prev) {
                      path.pop_back();
                      stk.pop();
                      prev = p;
                      p = nullptr;
                  } else {
                      p = p->right;
                  }
              }
          }
    
          TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
              vector<TreeNode*> path1, path2;
              getPath(root, p, path1);
              getPath(root, q, path2);
              int n = min(path1.size(), path2.size());
              TreeNode *last = nullptr;
              for (int i = 0; i < n; i++) {
                  if (path1[i] != path2[i]) return last;
                  last = path1[i];
              }
              return last;
          }
      };
    #+end_src
*** Question:                                                     :QUESTIONS:
    - [ ] 打印路径法怎么提速?迭代实现?
    - [ ] 后序遍历法的理解?
    - [ ] 联系对比 [[ilink22][offer12]] [[ilink33][offer13]] [[ilink30][offer27]] [[ilink31][offer33]] [[ilink32][offer34]] [[ilink33][offer38]] [[ilink34][offer46]] 思考关于 dfs 回溯 递归 后序遍历
